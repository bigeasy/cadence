<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <title>Cadence</title>
<!--
<link href='http://fonts.googleapis.com/css?family=Parisienne|Oxygen+Mono|PT+Mono|Offside|Nova+Mono|Averia+Serif+Libre|Alex+Brush|Autour+One|Share+Tech+Mono|Merriweather|Maven+Pro|Raleway' rel='stylesheet' type='text/css'>
-->
<!-- todo: why doesn't fork me float? -->
<link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
<link rel="stylesheet" type="text/css" href="css/ascetic.css">
<link rel="stylesheet" type="text/css" href="css/cadence.css">
<body><a href="https://github.com/bigeasy/cadence/"><img style="position: fixed; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a><div class="container">

<div class="unit welcome">
<h1>Cadence</h1>
</div>
<!-- todo: code font is too small for body text font -->
<div class="unit description markdown"><p>Cadence is a control-flow library for error-first callback style of asynchronous
programming. You can reason about asynchronous programming as if it were linear. Say good bye
to the <a href="http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/">Pyramid of
Doom</a>.</p>
<p>Say hello to Cadence; one step after another, with robust try/catch error
handling, finalizers, nested asynchronous loops with break and contine, and
tail-recursion elimination to you&apos;ll never blow your stack looping.</p>
<p>Here&apos;s a function that will delete a file if it exists.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>)
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)
<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;path&apos;</span>)

<span class="hljs-keyword">var</span> deleteIf = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, file</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path.dirname(file), <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">files</span>) </span>{

        <span class="hljs-keyword">if</span> (!files.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{ <span class="hljs-keyword">return</span> f == file }).length) {
            <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">async</span>, <span class="hljs-literal">false</span> ]
        }
        fs.unlink(file, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> [ <span class="hljs-literal">true</span> ]

    })

})

deleteIf(<span class="hljs-string">&apos;junk.txt&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, deleted</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-built_in">console</span>.log(error)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;junk.txt: was deleted &apos;</span> + deleted)
})
</code></pre>
<p>Of course that has a race condition, what if the file is deleted after you&apos;ve
read the directory but before you unlink it? A better way of doing this would be
to try to delete the file, but catch an <code>ENOENT</code> error if the file does not
exist.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-keyword">var</span> deleteIf = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, file</span>) </span>{

    <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">async</span>([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.unlink(file, <span class="hljs-keyword">async</span>())        <span class="hljs-comment">// try</span>

    }, <span class="hljs-regexp">/^ENOENT$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> [ block, <span class="hljs-literal">false</span> ]         <span class="hljs-comment">// catch ENOENT</span>

    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> [ <span class="hljs-literal">true</span> ]                 <span class="hljs-comment">// deleted</span>

    })()

})

deleteIf(<span class="hljs-string">&apos;junk.txt&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, deleted</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-built_in">console</span>.log(error)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;junk.txt: was deleted &apos;</span> + deleted)
})
</code></pre>
<p>In the above we use a catch block to catch an <code>ENOENT</code> error and return false,
otherwise return true. If an error other than <code>ENOENT</code> is raised, the the error
will be passed as the first argument.</p>
<h3 id="what-cadence-can-do-for-you">What Cadence Can Do for You</h3>
<p>Cadence is pure-JavaScript library control-flow library with no transpilers. The
Cadence kernel is designed to JIT compile and get out of the way.</p>
<p>Cadence can express all manner of asynchronous operations, including:</p>
<ul>
<li>serial asynchronous operations, of course</li>
<li>parallel asynchronous operations, naturally</li>
<li><code>while</code> loops, <code>do..while</code> loops, or <code>counted</code> loops</li>
<li>each loops that can either map or reduce an array</li>
<li><code>break</code> from labeled loops or <code>continue</code> them, even up out of nested loops to
an outer loop</li>
<li>asynchronous try and catch exception handling</li>
<li>asynchronous finalizers for clean up</li>
</ul>
<p>Cadence has features that you don&apos;t know you want&#x2026; yet:</p>
<ul>
<li>Have you been bitten by a stack overflow yet? Cadence runs your code in a
trampoline, so that asynchronous functions that callback in the same tick do
not add a stack frame.</li>
<li>Do you have a strategy to test every one of those <code>if (error)</code> branches?
Cadence handles your erorrs for you and propagates them up and out to the
user.</li>
<li>What about cleaning up after an error? You can&apos;t just <code>if (error)
callback(error)</code> if you have files open or databases on the line. Cadence has
try/catch blocks and finalizers.</li>
<li>Who is <code>this</code>? With Cadence <code>this</code> is consistent all throughout a function
body. You don&apos;t have to <code>bind(this)</code> or <code>var self = this</code> with Cadence.</li>
</ul>
<p>You can use Cadence in the browser too. It is not Node.js dependent and it
minzips to ~2.31k.</p>
<h3 id="cadence-in-a-nutshell">Cadence In a Nutshell</h3>
<p>Cadence runs a series of functions asynchronously, use the results of one
function as the arguments for the next.</p>
<p>We call the series of functions a <strong>cadence</strong>. We call an individual function in
a cadence a <strong>step</strong>.</p>
<p>We create cadences using the universal builder method <code>async</code>. It is a universal
because we also use <code>async</code> to create callbacks for asynchronous functions.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// `cat`: write a file to standard out.</span>
<span class="hljs-keyword">var</span> cat = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, file</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
 <span class="hljs-comment">//       ^^^^^^^^ create a cadence of one or more steps.</span>
        fs.readFile(file, <span class="hljs-string">&apos;utf8&apos;</span>, <span class="hljs-keyword">async</span>())
                               <span class="hljs-comment">// ^^^^^^^ create a callback.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{
              <span class="hljs-comment">// ^^^^ the result is passed to the next step.</span>

        process.stdout.write(body)

    })
})

cat(__filename, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
                       <span class="hljs-comment">// ^^^^^ any error, anywhere inside `cat` is propagated out</span>
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
})
</code></pre>
<p>Note that <strong>steps</strong> do not have receive errors. Errors get propagated up and out
to the caller. Your code does not need to be littered with <code>if (error)
callback(error)</code> branches that are difficult to reach in your tests. Your
asynchronous code is reduced to the happy path.</p>
<h2 id="cadence-basics">Cadence Basics</h2>
<p>Cadence exports a single function which by convention is named <code>cadence</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> list.some(filter)

    })
})

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isJavaScript</span> (<span class="hljs-params">file</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\.js$/</span>.test(file)
}

find(__dirname, isJavaScript, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, found</span>) </span>{

    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-built_in">console</span>.log(error)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (found) {
        <span class="hljs-built_in">console</span>.log(__dirname + <span class="hljs-string">&apos; contains a JavaScript file.&apos;</span>)
    }

})
</code></pre>
<p>Let&apos;s look closer at the <code>find</code> function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> list.some(filter)

    })

})
</code></pre>
<h3 id="function-body">Function Body</h3>
<p>We create the <code>find</code> function by invoking <code>cadence</code> with a single argument which
is the function body for <code>find</code>.  The <code>cadence</code> function will build a function
that, when invoked, will call the function body.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{
                <span class="hljs-comment">//        ^ function body</span>
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">  {

        fs.readdir(path, async(</span>))

    }, <span class="hljs-title">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> list.some(filter)

    })

})
</code></pre>
<h3 id="the-async-function">The <code>async</code> Function</h3>
<p>The first argument to the body is the universal builder function which by
convention is named <code>async</code>. It is named <code>async</code> because anywhere you see it,
you know that something asynchronous is going on.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{
                          <span class="hljs-comment">// ^^^^^ universal asynchronous builder function.</span>
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
 <span class="hljs-comment">// ^^^^^ it creates both cadences...</span>
        fs.readdir(path, <span class="hljs-keyword">async</span>())
                      <span class="hljs-comment">// ^^^^^ ...and callbacks</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> [ list.some(filter) ]

    })

})
</code></pre>
<h3 id="steps-and-cadences">Steps and Cadences</h3>
<p>When you invoke the <code>async</code> function with one or more functions, you create a
<strong>cadence</strong>. Each function is a <strong>step</strong> in the cadence.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;- let&apos;s create a cadence</span>
       <span class="hljs-comment">// ^^^^^^^^ step one</span>
        fs.readdir(path, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{
    <span class="hljs-comment">// ^^^^^^^^ step two</span>
        <span class="hljs-keyword">return</span> [ list.some(filter) ]

    })

})
</code></pre>
<h3 id="cadence-argument-progression">Cadence Argument Progression</h3>
<p>The results of one <strong>step</strong> in a <strong>cadence</strong> become the arguments of the next <strong>step</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())
                      <span class="hljs-comment">// ^^^^^ create a callback whose return value</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{
              <span class="hljs-comment">// ^^^^ is the argument of the next step</span>
        <span class="hljs-keyword">return</span> [ list.some(filter) ]

    })

})
</code></pre>
<p>The <code>async</code> function is used to create a callback that is given to <code>fs.readdir</code>.
The next <strong>step</strong> is called with the result of the previous <strong>step</strong>, but
without the error. The error is shifted off the arguments so that the next
<strong>step</strong> receives no errors, only results. There is no error for the <strong>step</strong> to
check. There is no need for an <code>if (error)</code> at every <strong>step</strong>.</p>
<h3 id="error-propagation">Error Propagation</h3>
<p>If an error does occur, it propagates out to the user. No matter how deeply
nested your <strong>cadences</strong>, an error will stop the <strong>cadence</strong> and return the
error to the user.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())
                      <span class="hljs-comment">// ^^^^^ an error returned to any callback...</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> [ list.some(filter) ]

    })

})

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isJavaScript</span> (<span class="hljs-params">file</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\.js$/</span>.test(file)
}

find(__dirname, isJavaScript, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, found</span>) </span>{
                                     <span class="hljs-comment">// ^^^^^ ...propagates out to here.</span>
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-built_in">console</span>.log(error)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (found) {
        <span class="hljs-built_in">console</span>.log(__dirname + <span class="hljs-string">&apos; contains a JavaScript file.&apos;</span>)
    }

})
</code></pre>
<h3 id="function-body-results">Function Body Results</h3>
<p>The results of the final <strong>step</strong> in a <strong>cadence</strong> are the results of the
<strong>cadence</strong>.</p>
<p>Notice that if a <strong>step</strong> does not invoke an asynchronous function, it can
simply return a result.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> [ list.some(filter) ]
     <span class="hljs-comment">// ^^^^^^ result of final step is the result of the cadence.</span>
    })

})
</code></pre>
<p>The results of all the <strong>cadences</strong> and <strong>callbacks</strong> in the function body are
the results of the function generated by <code>cadence</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-keyword">var</span> find = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, path, filter</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readdir(path, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>{

        <span class="hljs-keyword">return</span> [ list.some(filter) ]
     <span class="hljs-comment">// ^^^^^^ result of the only cadence...</span>
    })

})

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isJavaScript</span> (<span class="hljs-params">file</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\.js$/</span>.test(file)
}

find(__dirname, isJavaScript, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, found</span>) </span>{
                                            <span class="hljs-comment">// ^^^^^ ...is the result of function.</span>
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-built_in">console</span>.log(error)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (found) {
        <span class="hljs-built_in">console</span>.log(__dirname + <span class="hljs-string">&apos; contains a JavaScript file.&apos;</span>)
    }

})
</code></pre>
<h2 id="cadence-step-by-step">Cadence Step by Step</h2>
<p>Let&apos;s look at the rest of Cadence.</p>
<h3 id="our-friend-echo">Our Friend Echo</h3>
<p>In our examples we are going to use a function called echo which will invoke the
callback with the argument given. We&apos;re also going to assume that we have <code>ok</code>
and <code>equal</code> to assert what we believe to be true.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ok = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;assert&apos;</span>).ok
<span class="hljs-keyword">var</span> equal = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;assert&apos;</span>).equal

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params">value, callback</span>) </span>{
    setImmediate(callback, <span class="hljs-literal">null</span>, value)
}
</code></pre>
<h3 id="creating-callback-functions">Creating Callback Functions</h3>
<p>When you invoke <code>async</code> with no arguments, it builds a simple error first
<strong>callback</strong> function. Cadence will receive the results given to the
<strong>callback</strong> on your behalf and do the right thing.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> calledback = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

})

calledback(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;called back&apos;</span>)

})
</code></pre>
<h3 id="creating-cadences">Creating Cadences</h3>
<p>When you invoke <code>async</code> with one or more functions, you build a <strong>cadence</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> stepper = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
       <span class="hljs-comment">// ^^^^^^^^ one or more functions creates a cadence.</span>
        echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;stepped&apos;</span>)

        echo(value, <span class="hljs-keyword">async</span>())
                 <span class="hljs-comment">// ^^^^^ this will be the result of the cadence and the function.</span>
    })
})

stepper(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;called back&apos;</span>)

})
</code></pre>
<h3 id="propagating-errors">Propagating Errors</h3>
<p>Any error or exception that occurs in the function body is propagated to the
caller by default.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">brokenEcho</span> (<span class="hljs-params">value, callback</span>) </span>{
    callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;out of service&apos;</span>))
}

<span class="hljs-keyword">var</span> stepper = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        brokenEcho(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())
                   <span class="hljs-comment">// ^^^^^ this callback will propagate the error.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{ <span class="hljs-comment">// &lt;- the next step will not be called because of the error.</span>

        brokenEcho(value, <span class="hljs-keyword">async</span>())

    })
})

stepper(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{
               <span class="hljs-comment">// ^^^^^ our error, propagated.</span>
    equal(error.message, <span class="hljs-string">&apos;out of service&apos;</span>, <span class="hljs-string">&apos;errors propagate&apos;</span>)

})
</code></pre>
<h3 id="propagating-exceptions">Propagating Exceptions</h3>
<p>Exceptions are also propagated. You can throw an exception anywhere in the
function body and it will propagate out to the user as the error-first error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> stepper = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;out of service&apos;</span>)

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;- will not be called.</span>

        echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

    })
})

stepper(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{
               <span class="hljs-comment">// ^^^^^ our exception, propagated.</span>
    equal(error.message, <span class="hljs-string">&apos;out of service&apos;</span>, <span class="hljs-string">&apos;exceptions propagate&apos;</span>)

})
</code></pre>
<h3 id="function-body-arguments">Function Body Arguments</h3>
<p>The first argument to the function body is always the <code>async</code> function. The rest
of the arguments are the parameters passed to the <code>cadence</code> generated function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> arguable = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, value</span>) </span>{
                                     <span class="hljs-comment">// ^^^^^ from the caller.</span>
    <span class="hljs-keyword">async</span>(value, <span class="hljs-keyword">async</span>())

})

arguable(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{
      <span class="hljs-comment">// ^ `value` parameter in `arguable`.</span>
    equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;argument passed&apos;</span>)

})
</code></pre>
<p>Because the error-first callback conventions dictate that the error-first <code>callback</code> is the
last argument, you might wonder why <code>async</code> is the first.</p>
<p>We put the <code>async</code> as the first argument, not the last, because Cadence is
nothing without its <code>async</code> function. We&apos;re (almost) always going to need it so
it will always be passed into the function body as the first argument.</p>
<p>Also a <code>cadence</code> generated function always expects a callback. There is
no concept of optional callbacks.</p>
<p>Best of all, putting the <code>async</code> function at the head to make it easier to
implement variadic functions. No messy <code>var callback = vargs.pop()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> argumentCounter = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> vargs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
    step(vargs.length, <span class="hljs-keyword">async</span>())

})

arguable(<span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;b&apos;</span>, <span class="hljs-string">&apos;c&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, count</span>) </span>{

    equal(count, <span class="hljs-number">3</span>, <span class="hljs-string">&apos;three arguments&apos;</span>)

})
</code></pre>
<h3 id="multiple-callback-arguments">Multiple Callback Arguments</h3>
<p>Because error-first callbacks can receive multiple arguments, <strong>steps</strong> can
receive multiple arguments and a <strong>cadence</strong> can return multiple results.</p>
<p>Because a <strong>cadence</strong> can return multiple arguments a function body can also
return multiple arguments.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo2</span> (<span class="hljs-params">one, two, callback</span>) </span>{
    setImmediate(callback, <span class="hljs-literal">null</span>, one, two)
}

<span class="hljs-keyword">var</span> multi = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>)
    <span class="hljs-title">async</span>(<span class="hljs-params">function (</span>) </span>{

        echo2(<span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;b&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, second</span>) </span>{

        assert(first, <span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;one of two in step&apos;</span>)
        assert(second, <span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;two of two in step&apos;</span>)

        echo2(first, second, step())

    })
})

multi(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, first, second</span>) </span>{

    assert(first, <span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;one of two results&apos;</span>)
    assert(second, <span class="hljs-string">&apos;a&apos;</span>, <span class="hljs-string">&apos;two of two results&apos;</span>)

})
</code></pre>
<h3 id="synchronous-steps-using-return-">Synchronous Steps Using <code>return</code></h3>
<p>Sometimes <strong>steps</strong> do not need to call asynchronous functions. In that case we can
simply use <code>return</code> to pass a value to the next <strong>step</strong>, but only if the value
is not an array.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;return number&apos;</span>)

        echo(value, step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;sync worked&apos;</span>)

})
</code></pre>
<h3 id="returning-multiple-arguments-from-a-step">Returning Multiple Arguments from a Step</h3>
<p>When we want to synchronously return multiple values, we return an array of
arguments. The elements in the array are used as the arguments to the next
function, much like calling <code>apply</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, second</span>) </span>{

        equal(first, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;one of two&apos;</span>)
        equal(second, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;two of two&apos;</span>)

        echo(first + second, step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">3</span>, <span class="hljs-string">&apos;multiple argument sync worked&apos;</span>)

})
</code></pre>
<h3 id="returning-an-array-from-a-step">Returning an Array from a Step</h3>
<p>If you want to synchronously pass an array to the next <strong>step</strong>, you cannot
simply return the array, because the array elements will be used as the
arguments for the next <strong>step</strong>.</p>
<p>To synchronously pass an array to the next step, you return an array of
arguments that contians the array.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> values = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]

        <span class="hljs-keyword">return</span> [ values ]

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{

        ok(<span class="hljs-built_in">Array</span>.isArray(values), <span class="hljs-string">&apos;is an array&apos;</span>)
        equal(values.length, <span class="hljs-number">3</span>, <span class="hljs-string">&apos;is an array of three elements&apos;</span>)

        echo(values.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sum, value</span>) </span>{ <span class="hljs-keyword">return</span> sum + value }), step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">6</span>, <span class="hljs-string">&apos;array as a synchronous worked&apos;</span>)

})
</code></pre>
<h3 id="asynchronous-trumps-synchronous">Asynchronous Trumps Synchronous</h3>
<p>Asynchronous trumps synchronous. If you create a callback or a <strong>cadence</strong> using
<code>async</code> inside a <strong>step</strong>, then the return value of the <strong>step</strong> is ignored.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        echo(<span class="hljs-number">2</span>, <span class="hljs-keyword">async</span>())

        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;async trumps sync&apos;</span>)
        echo(value, step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;async wins&apos;</span>)

})
</code></pre>
<h3 id="cadences-within-cadences">Cadences within Cadences</h3>
<p>You can create a <strong>cadence</strong> in a <strong>cadence</strong> and you will. You can create a
<strong>cadence</strong> in any <strong>step</strong>. The result of the <strong>cadence</strong> is passed as an
argument to the next <strong>step</strong>.</p>
<p>A <strong>cadence</strong> is an asynchronous operation that will trump a return values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;- a cadence in a step.</span>

            echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

            echo(value + <span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())
                         <span class="hljs-comment">// ^^^^^ last callback of last step.</span>
        })

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;sub-cadence output&apos;</span>)
        echo(value, step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;cadences within cadences&apos;</span>)

})
</code></pre>
<p>Return values from <strong>cadences</strong> propagate up. Nest them as you see fit.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sync = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

            echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;- one step cadence, three cadences deep.</span>

                echo(value + <span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())
                             <span class="hljs-comment">// ^^^^^ this result goes up two cadences.</span>
            })

        })

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;sub-cadence output&apos;</span>)
        echo(value, step())

    })

})

sync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;cadences within cadences&apos;</span>)

})
</code></pre>
<h3 id="cadences-within-cadences-practical-application">Cadences within Cadences: Practical Application</h3>
<p>You will use <strong>cadences</strong> in <strong>steps</strong> in <strong>cadences</strong> to manage your scope. It
is a common construct.</p>
<p>In Cadence an indent means something. It means a new scope. You stay indented
when you have variables that need to be in scope for multiple asynchronous
operations. When the variables are no longer needed, the indent ends.</p>
<p>The following looks for the Unix execuable <a href="http://en.wikipedia.org/wiki/Shebang_%28Unix%29#Magic_number">magic
number</a>. <em>TK:
Create optional captions for code examples.</em></p>
<pre><code class="lang-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-comment">// `sip`: sip the first `count` bytes of a file.</span>
<span class="hljs-keyword">var</span> sip = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, file, count</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.open(file, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fd</span>) </span>{
              <span class="hljs-comment">// ^^ we need to use this for more than one step.</span>
        <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

            <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> Buffer(count)
            fs.read(buffer, <span class="hljs-number">0</span>, buffer.length, <span class="hljs-number">0</span>, step())

        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bytesRead, buffer</span>) </span>{
                  <span class="hljs-comment">// ^^^^^^^^^  ^^^^^^  must close the file descriptor  before we can return these.</span>
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

                fs.close(fd, step())

            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

                <span class="hljs-keyword">return</span> buffer.slice(<span class="hljs-number">0</span>, bytesRead) <span class="hljs-comment">// &lt;- we&apos;re three cadences deep</span>

            })

        })

    })

})

<span class="hljs-comment">// sip two bytes of a file and look for the executable magic number.</span>
sip(__filename, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    <span class="hljs-keyword">if</span> (value.length == <span class="hljs-number">2</span> &amp;&amp; value[<span class="hljs-number">0</span>] == <span class="hljs-number">0x23</span> &amp;&amp; value[<span class="hljs-number">1</span>] == <span class="hljs-number">0x21</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;I have a shebang line!&apos;</span>)
    }

})
</code></pre>
<h3 id="fallthrough-when-a-step-returns-nothing">Fallthrough when a Step Returns Nothing</h3>
<p>If you create a <strong>step</strong> that neither returns a value nor creates an
asynchronous operation using the <code>async</code> function, then the results of that
<strong>step</strong> are its arguments.</p>
<p>Put another way, if a <strong>step</strong> does not produce any results, then the <strong>next</strong>
step receives the results of the last <strong>step</strong> to produce results.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fallthrough = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;callback value&apos;</span>)

        <span class="hljs-built_in">console</span>.log(value)

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;callback value from step before last&apos;</span>)

        <span class="hljs-keyword">return</span> value + <span class="hljs-number">1</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;returned value&apos;</span>)

        <span class="hljs-built_in">console</span>.log(value)

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

        equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;returned value from step before last&apos;</span>)
                <span class="hljs-comment">// &lt;- no return or `async`, outcome is also a fall through.</span>
    })

})

fallthrough(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    equal(value, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;fell through&apos;</span>)

})
</code></pre>
<h3 id="parallel-versus-serial">Parallel versus Serial</h3>
<p>The <strong>steps</strong> in a <strong>cadence</strong> run in <em>serial</em>, one step after another.</p>
<p>The asynchronous operations in a <strong>step</strong> run in <em>parallel</em>. An asynchronous
operation in a <strong>step</strong> is a <strong>cadence</strong> or a function that invokes a
<strong>callback</strong>.</p>
<p>If you see <code>async</code> in a <strong>step</strong>, something asynchronous is going on. If you see
more than one <code>async</code> in a <strong>step</strong>, something parallel is going on.</p>
<p>Multiple the results of multiple asynchronous operations in a <strong>step</strong> are
gathered and passed as arguments to the next <strong>step</strong>. The next <strong>step</strong> is not
called until all the asynchronous operations finish.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> parallel = cadence(functions (<span class="hljs-keyword">async</span>) {

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        echo(<span class="hljs-number">1</span>, <span class="hljs-keyword">async</span>())            <span class="hljs-comment">// &lt;- first async call.</span>
        echo(<span class="hljs-number">2</span>, <span class="hljs-keyword">async</span>())            <span class="hljs-comment">// &lt;- second async call.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, second</span>) </span>{   <span class="hljs-comment">// &lt;- called when both echoes complete.</span>

        <span class="hljs-keyword">return</span> [ first, second ]

    })
})

parallel(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, first, second</span>) </span>{

    assert(first, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;one of two returned&apos;</span>)
    assert(second, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;two of two returned&apos;</span>)

})
</code></pre>
<p>The next <strong>step</strong> is called with the results of the mulitple <strong>callbacks</strong> or
<strong>cadences</strong>. The results are returned in the order in which their <strong>callback</strong>
or <strong>cadence</strong> was declared.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> parallel = cadence(functions (<span class="hljs-keyword">async</span>) {

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> first = <span class="hljs-keyword">async</span>()         <span class="hljs-comment">// &lt;- first callback.</span>
        <span class="hljs-keyword">var</span> second = <span class="hljs-keyword">async</span>()        <span class="hljs-comment">// &lt;- second callback.</span>

        second(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>)             <span class="hljs-comment">// &lt;- call second first, and right now.</span>
        echo(<span class="hljs-number">1</span>, first)              <span class="hljs-comment">// &lt;- call first on next tick.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, second</span>) </span>{

        assert(first, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;first order of callback do not matter&apos;</span>)
        assert(second, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;second order of callback do not matter&apos;</span>)

        <span class="hljs-keyword">return</span> [ first, second ]

    })
})

parallel(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, first, second</span>) </span>{

    assert(first, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;one of two returned&apos;</span>)
    assert(second, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;two of two returned&apos;</span>)

})
</code></pre>
<p>Parallel loops can be found below. That is the model for a bunch of identical
asynchronous operations running in parallel, or <em>homogeneous</em> parallel
operations. There you will see <code>async</code> but once, yet something parallel is going
on, so the above is a aphorism, not a hard rule.</p>
<p><em>TK: This might be moved to a usage section. The example can stay. The statement
above, plus the example. Anyway, on to arity.</em></p>
<p>Although there are mechanisms for homogeneous parallel operations, that sort of
parallelism is best obtained at the serivce level. Instead of having a
highly-parallel directory listing in your web server, let your web server serve
many directory listings in parallel, each being worked through in serial. You
will get similar performance, but with a lot less complexity.</p>
<p>The complexity comes in the error handling. If you can&apos;t read one file in a
directory, you probably can&apos;t read any of them. Now you have an array of errors
instead of an array of file statistics.</p>
<p>What we are discussing here are <em>heterogeneous</em> parallel operations, and they are
generally useful and easy to reason about. The make a lot of sense when you
need to to create funnel, performing multiple heterogeneous asynchronous
operations needed for the next <strong>step</strong>.</p>
<p>The following is a contrived initialization example.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> initialize = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step, conf</span>) </span>{

    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        db.connect(step())                      <span class="hljs-comment">// &lt;- connect to database.</span>
        fs.readFile(conf, <span class="hljs-string">&apos;utf8&apos;</span>, step())       <span class="hljs-comment">// &lt;- *and* slurp configuration.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">conn, conf</span>) </span>{                  <span class="hljs-comment">// &lt;- initialize the connection</span>
                                                <span class="hljs-comment">//       with the configuration.</span>
        conf = <span class="hljs-built_in">JSON</span>.parse(conf)

        conn.encoding = conf.encoding || <span class="hljs-string">&apos;UTF-8&apos;</span>
        conn.lang = conf.lang || <span class="hljs-string">&apos;en_US&apos;</span>

        <span class="hljs-keyword">return</span> conn

    })
})
</code></pre>
<h3 id="breaking-leaving-a-cadence-early">Breaking, Leaving a Cadence Early</h3>
<p><strong>TODO</strong>: This is gone, but maybe I&apos;ll have it back if it is super cheap.</p>
<p>You can leave a <strong>cadence</strong> by returning an array of arguments, the first
argument being the <code>async</code> function.</p>
<p>The mnemonic is that the first argument is an optional break, and <code>async</code> is
what you&apos;re breaking out of.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> early = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">async</span>, <span class="hljs-number">2</span> ]         <span class="hljs-comment">// &lt;- the `async` means break.</span>

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        echo(<span class="hljs-number">1</span>, value())            <span class="hljs-comment">// &lt;- never called.</span>

    })
})
</code></pre>
<p>You will use this construct all the time to end loops. You will also use it to
return early when you catch an exception.</p>
<p>The following is example of returing cached asynchronous operation early.</p>
<p>I&apos;ve said that asynchronous trumps synchronous, but <code>return</code> trumps anything
that follows it. That is why <code>return</code> makes for a nice break construct.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>), cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), config

<span class="hljs-built_in">module</span>.exports = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">if</span> (config) <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">async</span>, config ]

        fs.readFile(<span class="hljs-string">&apos;./config.json&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{

        <span class="hljs-keyword">return</span> [ config = <span class="hljs-built_in">JSON</span>.parse(body) ]

    })

})
</code></pre>
<h3 id="forever-loops">Forever Loops</h3>
<p>A loops is a <strong>cadence</strong> that repeats itself. When we create a <strong>cadence</strong>, the
<code>async</code> function returns a loop function that we can use to invoke the
<strong>cadence</strong> as a loop.</p>
<p>By convention, we call this loop function immediately.</p>
<p>This is an endless loop. In order to leave the loop we need to break from the
<strong>cadence</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> loopy = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) {
            <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">async</span>, count ]     <span class="hljs-comment">// &lt;- break and return count.</span>
        } <span class="hljs-keyword">else</span> {
            count++
        }

    })()
   <span class="hljs-comment">// ^^ loop forever.</span>
})

loopy(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;looped&apos;</span>)

})
</code></pre>
<h3 id="counted-loops">Counted Loops</h3>
<p>We can specify a count for a loop by passing a count to the loop starter
function. The count must be an integer greater than or equal to zero. The loop
will run count times.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> counted = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

            count++

        })(<span class="hljs-number">4</span>)
        <span class="hljs-comment">// ^ the above cadence is run four times.</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;- not called until loop in previous step finishes.</span>

        <span class="hljs-keyword">return</span> count

    })

})

counted(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">4</span>, <span class="hljs-string">&apos;counted&apos;</span>)

})
</code></pre>
<h3 id="counted-loop-result">Counted Loop Result</h3>
<p>The result of a counted loop is the value returned by the last loop iteration,
which is also the last run of the <strong>cadence</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> counted = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">return</span> ++count
              <span class="hljs-comment">// ^^^^^ returned as loop result on last run of the cadence.</span>
    })(<span class="hljs-number">4</span>)
    <span class="hljs-comment">// ^ the above cadence is run four times.</span>
})

counted(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">4</span>, <span class="hljs-string">&apos;counted&apos;</span>)

})
</code></pre>
<h3 id="the-counted-loop-index-argument">The Counted Loop Index Argument</h3>
<p>The first argument to the <strong>cadence</strong> of a counted loop is the always index of
the current count.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> counted = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{

        <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span>
            <span class="hljs-comment">// ^^^^^ on the last run of the cadence, index is three.</span>
    })(<span class="hljs-number">4</span>)
    <span class="hljs-comment">// ^ the above cadence is run four times.</span>
})

counted(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">4</span>, <span class="hljs-string">&apos;counted&apos;</span>)

})
</code></pre>
<h3 id="counted-loop-additional-arguments">Counted Loop Additional Arguments</h3>
<p>While the first argument to the counted loop <strong>cadence</strong> is the always index of
the current count, you can pass additional arguments into the loop <strong>cadence</strong>
by specifying them after the count.</p>
<p>The arguments after the index argument are the arguments passed to the loop
starter on the first iteration.</p>
<p>On subsequent iterations the arguments after the index argument are the results
of the previous iteration, the previous invocation of the <strong>cadence</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> reduce = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, sum</span>) </span>{
                        <span class="hljs-comment">// ^^^ initial argument or result of last iteration.</span>
        <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span> + sum

    })(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)
       <span class="hljs-comment">// ^ initial argument.</span>
})

reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;reduced sum&apos;</span>)

})
</code></pre>
<h3 id="each-loops">Each Loops</h3>
<p>When you pass an array as the first argument to the loop starter function, you
create an each loop. An each loop will run the loop <strong>cadence</strong> once for each
entry in the array. The array entry is passed into the first <strong>step</strong> of the
<strong>cadence</strong> as the first argument.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sum = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) </span>{
                 <span class="hljs-comment">// ^^^^^^ one array element at a time.</span>
        <span class="hljs-keyword">return</span> sum + number

    })([ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ])
    <span class="hljs-comment">// ^^^^^^^^^^^ array argument to loop function.</span>
})

sum(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;summed&apos;</span>)

})
</code></pre>
<h3 id="each-loop-index-argument">Each Loop Index Argument</h3>
<p>The second argument to an each loop <strong>cadence</strong> is the index of the entry in the
array.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sum = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number, index</span>) </span>{
                         <span class="hljs-comment">// ^^^^^ index of array entry.</span>
        <span class="hljs-keyword">return</span> sum + (number - index)

    })([ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ])

})

sum(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">3</span>, <span class="hljs-string">&apos;sum of ones&apos;</span>)

})
</code></pre>
<h3 id="each-loop-additional-arguments">Each Loop Additional Arguments</h3>
<p>You can pass arguments to the each loop <strong>cadence</strong> by passing them in after the
each loop array.</p>
<p>The arguments after the array argument are the arguments passed to the loop
starter on the first iteration.</p>
<p>On subsequent iterations the arguments after the index argument are the results
of the previous iteration, the previous invocation of the <strong>cadence</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> reduce = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number, index, sum</span>) </span>{
                                <span class="hljs-comment">// ^^^ initial argument or result of last iteration.</span>
        <span class="hljs-keyword">return</span> sum + number

    })([ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ], <span class="hljs-number">0</span>)
                 <span class="hljs-comment">// ^ initial argument.</span>
})

reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;reduced sum&apos;</span>)

})
</code></pre>
<h3 id="forever-loop-arguments">Forever Loop Arguments</h3>
<p>If you want to parse arguments into your loop <strong>cadence</strong> but you do not want a
counted loop nor an each loop, then you create a forever loop by creating a
counted loop with an unreachable count such as <code>-1</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> until = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, done</span>) </span>{

        <span class="hljs-keyword">if</span> (done) [ <span class="hljs-keyword">async</span>, count ]

        <span class="hljs-keyword">return</span> ++count == <span class="hljs-number">10</span>

    })(<span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>)
    <span class="hljs-comment">// ^^  ^^^^^ unreachable count and initial argument.</span>
})

until(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{

    assert(value, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;reduced sum&apos;</span>)

})
</code></pre>
<h3 id="gathered-loops">Gathered Loops</h3>
<p>Loops can gather their results into an array. To specify that a loop should
gather results, pass an array as the first argument to the loop starter. You can
use an array literal. This array is only used to signal that results should be
gathered, it is not the array used to gather results.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> squares = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{

    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{

        <span class="hljs-keyword">return</span> index * index

    })([], <span class="hljs-number">3</span>)
    <span class="hljs-comment">// ^^  ^ gather a counted loop.</span>
})

squares(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, array</span>) </span>{

    assert(array[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-string">&apos;first gathered value&apos;</span>)
    assert(array[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>, <span class="hljs-string">&apos;second gathered value&apos;</span>)
    assert(array[<span class="hljs-number">2</span>], <span class="hljs-number">4</span>, <span class="hljs-string">&apos;thrid gathered value&apos;</span>)

})
</code></pre>
<h3 id="loops-nested-in-cadences">Loops Nested in Cadences</h3>
<p>All of the above loop examples can be used in any <strong>step</strong> in any <strong>cadence</strong>.</p>
<h2 id="here-be-dragons">Here Be Dragons</h2>
<p>After this point is old documentation. I&apos;m pulling anything useful up above this
heading. Anything you read below is goofy and dubious.</p>
<p>Cadence might be as verbose as something you might write yourself, in fact is
might be more verbose, but while you&apos;ll have more characters, you&apos;ll have fewer
conditions. I&apos;m not trying to save characters. I&apos;m not trying to save
keystrokes. I&apos;m trying to save work. I&apos;m trying to save cognition.</p>
<h2 id="recursion">Recursion</h2>
<p>Cadence creates an error-first asynchronous function. If you need to perform a
recursive operation in Cadence, then call the function generated by <code>cadence</code>.</p>
<h2 id="reuse">Reuse</h2>
<p>By convention steps are <em>anonymous</em> functions. We do not create <strong>step</strong>
functions that we reuse. If we want to reuse a <strong>step</strong> or a series of
<strong>steps</strong>, we simply create a new function using <code>cadence</code> and call that
function the way we would any other error-first asynchronous function.</p>
<h3 id="cadences-within-steps-within-cadences">Cadences Within Steps Within Cadences</h3>
<p>You can define a cadence within a step. This let&apos;s you work with results of an
asynchronous call.</p>
<p>Let&apos;s say that we want to get a <code>stat</code> object, but include the body of the file
in the <code>stat</code> object. When we get our <code>stat</code> object, we can use a sub-cadence to
complete the <code>stat</code> object by reading the body.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-built_in">module</span>.exports = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step, file</span>) </span>{
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        fs.stat(file, step())
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stat</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-comment">// sub-cadence</span>
            fs.readFile(file, <span class="hljs-string">&apos;utf8&apos;</span>, step())
        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) </span>{
            stat.body = body
            <span class="hljs-keyword">return</span> stat;
        })
    })
})
</code></pre>
<p>This happens quite often actually. Sometimes you&apos;ve already invoked the
asynchronous function and have a copy of the result. Other times you want to do
some synchronous processing of the result of an asynchronous call. The example
below illustrates both cases.</p>
<p>Returning an array is a special case. When you return an array the elements of
the array are used as the arguments to the subsequent function.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one, two, three</span>) </span>{
        equal(one, <span class="hljs-number">1</span>, <span class="hljs-string">&apos;returned one&apos;</span>)
        equal(two, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;returned two&apos;</span>)
        equal(three, <span class="hljs-number">3</span>, <span class="hljs-string">&apos;returned three&apos;</span>)
    })
})
</code></pre>
<p>What if you want to return an array as the sole argument to the subsequent
function? Then put the array in an array as the sole element.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> [ [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ] ]
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) </span>{
        equal(array[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-string">&apos;element one&apos;</span>)
        equal(array[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>, <span class="hljs-string">&apos;element two&apos;</span>)
        equal(array[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-string">&apos;element three&apos;</span>)
    })
})
</code></pre>
<p>We&apos;re going to use this construct in a bit to break out of loops</p>
<h3 id="catching-errors">Catching Errors</h3>
<p>Cadence encourages parallelism, and because parallel operations can also
fail in parallel and/or raise many exceptions in parallel (fun stuff),
its internal error handling mechanism deals with arrays of errors.</p>
<p>Externally, however, your caller is expecting one single error, because Cadence
builds a function that follows the error-first callback standard. Thus, even
when there are many errors, the default is to return the first error that occurs
in the cadence.</p>
<p>When an error occurs, Cadence waits for all parallel operations to complete,
then it raises the error along with any other errors that occured in parallel.
If you want to catch these errors, create a try/catch function pair by wrapping
it in an array.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Do something stupid.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        <span class="hljs-comment">// Catch the exception.</span>
        ok(errors[<span class="hljs-number">0</span>].code == <span class="hljs-string">&apos;EACCES&apos;</span>, <span class="hljs-string">&apos;caught EACCES&apos;</span>)
        ok(errors.length == <span class="hljs-number">1</span>, <span class="hljs-string">&apos;caught EACCES and only EACCES&apos;</span>)

    }])
})()
</code></pre>
<p>In the above, we catch the <code>EACCES</code> that is raised when we attempt to read a
read-protected file. Note the array that binds the catch function to the step
that proceeds it.</p>
<p>If no error occurs, the catch function is not invoked. The next function in the
cadence after the try/catch pair is invoked with the successful result of the
try function.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read a readable file.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/hosts&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        <span class="hljs-comment">// This will not be called.</span>
        proecss.stderr.write(<span class="hljs-string">&apos;Hosts file is missing!\n&apos;</span>)

    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hosts</span>) </span>{

        process.stdout.write(hosts)

    })
})()
</code></pre>
<p>When an error triggers the catch function, the catch function can recover and
continue the cadence by returning normally.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read file that might be missing.</span>
        fs.readFile(env.HOME + <span class="hljs-string">&apos;/.config&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        <span class="hljs-comment">// That didn&apos;t work, for whatever reason, so try the global.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/config&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{

        process.stdout.write(config)

    })
})()
</code></pre>
<p>Also note that both the try function and error function can use sub-cadences,
arrayed cadences, fixups, etc.; everything that Cadence has to offer.</p>
<p>A catch function also catches thrown exceptions.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;thrown&apos;</span>)

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        ok(errors[<span class="hljs-number">0</span>].message == <span class="hljs-string">&apos;thrown&apos;</span>, <span class="hljs-string">&apos;caught thrown&apos;</span>)
        ok(errors.length == <span class="hljs-number">1</span>, <span class="hljs-string">&apos;caught thrown and only thrown&apos;</span>)

    }])
})()
</code></pre>
<p>Errors are provided in an <code>errors</code> array. Why an array, again? Because with Cadence,
you&apos;re encouraged to do stupid things in parallel.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read two read-protected files.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        ok(errors[<span class="hljs-number">0</span>].code == <span class="hljs-string">&apos;EACCES&apos;</span>, <span class="hljs-string">&apos;caught EACCES&apos;</span>)
        ok(errors[<span class="hljs-number">1</span>].code == <span class="hljs-string">&apos;EACCES&apos;</span>, <span class="hljs-string">&apos;caught another EACCES&apos;</span>)
        ok(errors.length == <span class="hljs-number">2</span>, <span class="hljs-string">&apos;caught two EACCES&apos;</span>)

    }])
})()
</code></pre>
<p>Note that the errors are indexed in the <strong>order in which they were caught</strong>,
not in the order in which their callbacks were declared.</p>
<p>The second argument to a function callback is the first error in the errors
array. This is in case you&apos;re certain that you&apos;ll only ever get a single error,
and the array subscript into the <code>errors</code> array displeases you.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors, error</span>) </span>{

        ok(error.code == <span class="hljs-string">&apos;EACCES&apos;</span>, <span class="hljs-string">&apos;caught EACCES&apos;</span>)

    }])
})()
</code></pre>
<p>For the sake of style, when you don&apos;t want to reference the errors array, you
can of course hide it using <code>_</code> or, if that is already in use, double <code>__</code>.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, error</span>) </span>{

        ok(error.code == <span class="hljs-string">&apos;EACCES&apos;</span>, <span class="hljs-string">&apos;caught EACCES&apos;</span>)

    }])
})()
</code></pre>
<h3 id="propagating-errors">Propagating Errors</h3>
<p>You can propagate all of the caught errors by throwing the <code>errors</code> array.</p>
<p>Imagine a system where sudo is not installed (as is the case with a base
FreeBSD.)</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read two read-protected files.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        <span class="hljs-comment">// Maybe sudo isn&apos;t installed and we got `ENOENT`?</span>
        <span class="hljs-keyword">if</span> (!errors.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{ <span class="hljs-keyword">return</span> error.code == <span class="hljs-string">&apos;EACCES&apos;</span> })) {
            <span class="hljs-keyword">throw</span> errors
        }

    }])
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{

    <span class="hljs-comment">// Only the first exception raised is reported to the caller.</span>
    <span class="hljs-keyword">if</span> (error) <span class="hljs-built_in">console</span>.log(error)

})
</code></pre>
<p>You can also just throw an exception of your chosing.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read two read-protected files.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        <span class="hljs-comment">// Maybe sudo isn&apos;t installed and we got `ENOENT`?</span>
        <span class="hljs-keyword">if</span> (!errors.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{ <span class="hljs-keyword">return</span> error.code == <span class="hljs-string">&apos;EACCES&apos;</span> })) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;something bad happened&apos;</span>)
        }

    }])
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{

    ok(error.message, <span class="hljs-string">&apos;something bad happened&apos;</span>)

})
</code></pre>
<p>When you raise an error in a catch function, it cannot be caught in the current
cadence. You can still catch it in a calling cadence, however.</p>
<p>Here we log any errors before raising them all up to the default handler:</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

            <span class="hljs-comment">// Read two read-protected files.</span>
            fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
            fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

            <span class="hljs-comment">// Maybe sudo isn&apos;t installed and we got `ENOENT`?</span>
            <span class="hljs-keyword">if</span> (!errors.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{ <span class="hljs-keyword">return</span> error.code == <span class="hljs-string">&apos;EACCES&apos;</span> })) {
                <span class="hljs-keyword">throw</span> errors
            }

        }])
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

      errors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(error) })
      <span class="hljs-keyword">throw</span> errors

  }])
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{

    ok(error, <span class="hljs-string">&apos;got a single error&apos;</span>)

})
</code></pre>
<p>As you can see, Cadence will catch exceptions as well as handle errors passed to
callbacks.</p>
<h3 id="conditional-error-handling">Conditional Error Handling</h3>
<p>Dealing with an array of errors means you&apos;re almost always going to want to
filter the array to see if it contains the error you&apos;re expecting, and which error
that might be. Because this is so common, it&apos;s built into Cadence.</p>
<p>To create a try/catch pair that will respond only to certain errors, add a
regular expression between the try function and the catch function.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Read file that might be missing.</span>
        fs.readFile(env.HOME + <span class="hljs-string">&apos;/.config&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }, <span class="hljs-regexp">/^ENOENT$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// That didn&apos;t work because the file does not exist, try the global.</span>
        fs.readFile(<span class="hljs-string">&apos;/etc/config&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>, step())

    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{

        process.stdout.write(config)

    })
})()
</code></pre>
<p>In the above example, we only catch an exception if the <code>code</code> property matches
/ENOENT/. If there is a different error- say, the file exists but we can&apos;t
read it- that error is not caught by our try/catch pair.</p>
<p>The condition is tested against the <code>code</code> property if it exists. If it doesn&apos;t
exist then it is tested against the <code>message</code> property.</p>
<p>You can easily test for multiple error codes using a regular expression, as
well. Here we test for both <code>EACCES</code> and <code>ENOENT</code>.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-regexp">/^(EACCES|ENOENT)$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        ok(errors.length == <span class="hljs-number">2</span>, <span class="hljs-string">&apos;handled&apos;</span>)

    }])
})()
</code></pre>
<p>You can also be explicit about the property used to test by adding the name of
that property between the try function and the condition. Here we explicitly
state that the <code>code</code> property is the property to test.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-string">&apos;code&apos;</span>, <span class="hljs-regexp">/^(EACCES|ENOENT)$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        ok(errors.length == <span class="hljs-number">2</span>, <span class="hljs-string">&apos;handled&apos;</span>)

    }])
})()
</code></pre>
<p>If the condition does not match all the examples raised, then the catch function
is not invoked, and the errors are propagated.</p>
<p>However, if the errors are not caught and propagated out of Cadence and to the
caller, then the caller will receive the first exception that did not match the
conditional.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        step()(<span class="hljs-literal">null</span>,
        fs.readFile(<span class="hljs-string">&apos;/etc/sudoers&apos;</span>, step())
        fs.readFile(<span class="hljs-string">&apos;/etc/shadow&apos;</span>, step())

    }, <span class="hljs-regexp">/^(EACCES|ENOENT)$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errors</span>) </span>{

        ok(errors.length == <span class="hljs-number">2</span>, <span class="hljs-string">&apos;handled&apos;</span>)

    }])
})()
</code></pre>
<p>Why? Because we can only return one exception to the caller, so it is better to
return the unexpected exception that caused the condition to fail, even if it
was not the first exception raised by the Cadence. It makes it clear that the
condition is failing because of additional errors.</p>
<p>TK: Throwing errors resets the concept of unmatched.</p>
<h4 id="error-catching-example">Error Catching Example</h4>
<p>Let&apos;s extend our <code>deleteIf</code> function. Let&apos;s say that if the file doesn&apos;t exist,
we ignore the error raised when we stat the file. To catch the error we wrap our
call to <code>stat</code> in a try/catch function pair. If the call to <code>stat</code> results in
<code>ENOENT</code>, our catch function is called. The catch function simply returns early
because ther is no file to delete.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Use Cadence.</span>
<span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

<span class="hljs-comment">// Delete a file if it exists and the condition is true.</span>
<span class="hljs-keyword">var</span> deleteIf = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step, file, condition</span>) </span>{
    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        fs.stat(file, step())

    }, <span class="hljs-regexp">/^ENOENT$/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{

        <span class="hljs-comment">// TK: Early return example can be if it is a directory, return early.</span>
        step(<span class="hljs-literal">null</span>)

    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stat</span>) </span>{

      <span class="hljs-keyword">if</span> (stat &amp;&amp; condition(stat)) fs.unlink(step())

    })
})

<span class="hljs-comment">// Test to see if a file is empty.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span> (<span class="hljs-params">stat</span>) </span>{ <span class="hljs-keyword">return</span> stat.size == <span class="hljs-number">0</span> }

<span class="hljs-comment">// Delete a file if it exists and is empty.</span>
deleteIf(__filename, empty, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{ <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error })
</code></pre>
<p>We test to see if the error is <code>ENOENT</code>. If not, we have a real problem, so we
throw the error. The throw is caught and forwarded to the callback that invoked
the cadence function.</p>
<p>If the error is <code>ENOENT</code>, we exit early by calling the step function directly as
a if it were itself an error/result callback, passing <code>null</code> to indicate no
error.</p>
<h2 id="working-with-events">Working with Events</h2>
<p>Cadence also works with event emitting objects that do not accept an error as
the first parameter. These are event mechanisms like the DOM events or the
events generated by the Node.js <code>EventEmitter</code>.</p>
<p>To indicate that you want an event handler, use <code>-1</code> as the first parameter to
the <code>step</code> function.</p>
<p>Why is <code>-1</code> the mnemonic for an event? Think of the the <code>-1</code> as a shift of
sorts, we&apos;re moving things to the left by one. Negative numbers are to the left.
Isn&apos;t syntax bashing fun?</p>
<p>Here is a unit test for working with <code>EventEmitter</code> illustrating the use of
events in Cadence.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), event = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;event&apos;</span>)
  , ee = <span class="hljs-keyword">new</span> event.EventEmitter()

cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step, ee</span>) </span>{
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        ee.on(<span class="hljs-string">&apos;data&apos;</span>, step(<span class="hljs-number">-1</span>, []))
        ee.on(<span class="hljs-string">&apos;end&apos;</span>, step(<span class="hljs-number">-1</span>))
        ee.on(<span class="hljs-string">&apos;error&apos;</span>, step(<span class="hljs-built_in">Error</span>))
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        assert.deepEqual(data, [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ])
    })
})(emitter)

ee.emit(<span class="hljs-string">&apos;data&apos;</span>, <span class="hljs-number">1</span>)
ee.emit(<span class="hljs-string">&apos;data&apos;</span>, <span class="hljs-number">2</span>)
ee.emit(<span class="hljs-string">&apos;data&apos;</span>, <span class="hljs-number">3</span>)

ee.emit(<span class="hljs-string">&apos;end&apos;</span>)
</code></pre>
<p>Below we use the example of splitting an HTTP server log for many hosts
into a log file for each host.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;cadence&apos;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>)

cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> readable = fs.readableStream(__dirname + <span class="hljs-string">&apos;/logins.txt&apos;</span>)
        readable.setEncoding(<span class="hljs-string">&apos;utf8&apos;</span>)
        readable.on(<span class="hljs-string">&apos;data&apos;</span>, step.event([]))
        readable.on(<span class="hljs-string">&apos;end&apos;</span>)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">var</span> hosts = {}
        data.join(<span class="hljs-string">&apos;&apos;</span>).split(<span class="hljs-regexp">/\n/</span>).foreach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
            <span class="hljs-keyword">var</span> host = <span class="hljs-regexp">/^([\w\d.]+)\s+(.*)/</span>.exec(line)[<span class="hljs-number">1</span>]
            (hosts[host] || (hosts[host])).push(line)
        })
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> host <span class="hljs-keyword">in</span> hosts) {
            <span class="hljs-keyword">var</span> writable = fs.writableStream(__dirname + <span class="hljs-string">&apos;/&apos;</span> + host + <span class="hljs-string">&apos;.log&apos;</span>)
            writable.end(hosts[host].join(<span class="hljs-string">&apos;\n&apos;</span>) + <span class="hljs-string">&apos;\n&apos;</span>)
            writable.on(<span class="hljs-string">&apos;drain&apos;</span>, step.event())
        }
    })
})()
</code></pre>
<p>This is a horrible example. Try again.</p>
<p>Here&apos;s a <code>mkdirp</code>, but let&apos;s complete it.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mkdirs = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step, directory</span>) </span>{
    directory = path.resolve(directory)
    <span class="hljs-keyword">var</span> mode = <span class="hljs-number">0777</span> &amp; (~process.umask())
    <span class="hljs-keyword">var</span> made = <span class="hljs-literal">null</span>

    step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        fs.mkdir(directory, mode, step())
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, error</span>) </span>{
        <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">&apos;ENOENT&apos;</span>) {
            mkdirp(path.dirname(directory), step())
        } <span class="hljs-keyword">else</span> {
            step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                fs.stat(directory, step())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stat</span>) </span>{
                <span class="hljs-keyword">if</span> (!stat.isDirectory()) step(error)
            })
        }
    }])
})
</code></pre>
<h2 id="loops">Loops</h2>
<p>TK: Serial and parallel loops, but parallel doesn&apos;t really loop.</p>
<h3 id="serial-loops">Serial Loops</h3>
<p>TK: So, just Loops, then? What about Serial Each and Parallel Each?
TK: Do examples look better without commas?</p>
<p>Cadence wants you to use nesting to represent subordinate operations, so it wants
to provide you with a looping structure that is not terribily compilicated, or
nested.</p>
<p>Looping in Cadence is performed by defining a sub-cadence, then invoking the
function that is returned by the sub-cadence definition. We&apos;ll call this the
<strong>looper function</strong>. If you <strong>do not invoke</strong> the function, Cadence will start
the sub-cadence for you when your step returns and run the sub-cadence once. If
you <strong>do invoke</strong> the function, Cadence will run the sub-cadence as a loop.</p>
<p>You can create <code>while</code> loops, <code>do...while</code> loops, stepped loops and <code>forEach</code>
loops using the looper function.</p>
<h3 id="endless-loops">Endless Loops</h3>
<p>If you invoke without arguments, you will invoke an endless loop. You terminate
the loop using the <code>step(error, result)</code> explicit return.</p>
<p>Calling <code>looper()</code>.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        count++
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) step(<span class="hljs-literal">null</span>, count)
    })() <span class="hljs-comment">//immediate invocation</span>
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;loop&apos;</span>)
})()
</code></pre>
<p>When your terminal condition is the last function, you&apos;ve basically created a
<code>do...while</code> loop.</p>
<h3 id="loop-initializers">Loop Initializers</h3>
<p>When an endless loop iterates, the result of the last function is passed as
arguments to the first function. You can use this to create a <code>while</code> loop.</p>
<p>To pass in an initial test value to the endless loop, you invoke the looper
function with a leading <code>null</code>, followed by the parameters, <code>looper(null, arg1,
arg2)</code> the same the way you invoke an explicit return of the <code>step</code> function.</p>
<p>Calling <code>looper(null, arg)</code>.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">more</span>) </span>{
          <span class="hljs-keyword">if</span> (!more) step(<span class="hljs-literal">null</span>, count)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          step()(<span class="hljs-literal">null</span>, ++count &lt; <span class="hljs-number">10</span>)
    })(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;initialized loop&apos;</span>)
})
</code></pre>
<h3 id="counted-loops">Counted Loops</h3>
<p>You can tell Cadence to loop for a fixed number of times by invoking the loop
start function with a count of iterations.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">count</span>) </span>{
        equal(count, index, <span class="hljs-string">&apos;keeping a count for you&apos;</span>)
        step()(<span class="hljs-literal">null</span>, ++count)
    })(<span class="hljs-number">10</span>)
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;counted loop&apos;</span>)
})
</code></pre>
<h3 id="each-loops">Each Loops</h3>
<p>You can invoke the loop passing it an array. The loop will be invoked once for
each element in the array, passing the array element to the first function of
the sub-cadence.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number, index</span>) </span>{
        equal(index, number - <span class="hljs-number">1</span>, <span class="hljs-string">&apos;keeping an index for you&apos;</span>)
        step()(<span class="hljs-literal">null</span>, sum = sum + number)
    })([ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ])
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;reduced each loop&apos;</span>)
})
</code></pre>
<h3 id="gathered-loops">Gathered Loops</h3>
<p>Both counted loops and each loops can be gathered into an array. If you pass an
initial array to the callback function, then each iteration will be gathered
into an array result.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>
    step(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        step()(<span class="hljs-literal">null</span>, ++count)
    })([], [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ])
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    deepEqual(result, [ <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span> ], <span class="hljs-string">&apos;gathered each loop&apos;</span>)
})
</code></pre>
<p>You cannot gather endless loops.</p>
<h3 id="loop-labels">Loop Labels</h3>
<p>If you want to give up early and try again, you can use a loop label. When you
invoke the looper function it returns a label object. You can use the label
object to restart the loop.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> retry = step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (++count != <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>
        <span class="hljs-keyword">else</span> step(<span class="hljs-literal">null</span>, <span class="hljs-number">10</span>)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        step(retry)
    }])(<span class="hljs-number">1</span>)
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;loop continue&apos;</span>)
})
</code></pre>
<p>This one&apos;s tricky. Because we specified a count of <code>1</code>, the loop will only loop
once, but because we call the <code>retry</code> label when we catch an error, the loop
tries again.</p>
<h3 id="loop-label-quick-returns">Loop Label Quick Returns</h3>
<p>Some of the things we document here are about style and syntax bashing that you
can do. It&apos;s not necessarily a part of Cadence.</p>
<p>Often times when working with labels, you&apos;re testing to see if you should invoke
the label when you enter a function; if not you would like to do something else.
This is going to create an <code>if/else</code> block that increases our nesting. If we
were programming synchronously in plain old JavaScript, we could call <code>continue</code>
and that would jump to the loop label.</p>
<p>To preserve that jumpy feeling, when you invoke <code>step(label)</code> it returns true,
so you can create a return using <code>&amp;&amp;</code>.</p>
<pre><code class="lang-javascript">cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">step</span>) </span>{
    <span class="hljs-keyword">var</span> retry = step([<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">count</span>) </span>{
        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;retry&apos;</span>)
        <span class="hljs-keyword">else</span> step(<span class="hljs-literal">null</span>, <span class="hljs-number">10</span>)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, error</span>) </span>{
        <span class="hljs-keyword">if</span> (error.message == <span class="hljs-string">&apos;retry&apos;</span>) <span class="hljs-keyword">return</span> step(retry) &amp;&amp; count + <span class="hljs-number">1</span>
        <span class="hljs-keyword">throw</span> error
    }])(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
})(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    equal(result, <span class="hljs-number">10</span>, <span class="hljs-string">&apos;loop continue&apos;</span>)
})
</code></pre>
<p>TK: Another example of this...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (count != stop) <span class="hljs-keyword">return</span> step(retry) &amp;&amp; <span class="hljs-keyword">return</span> count + <span class="hljs-number">1</span>
</code></pre>
<h2 id="control-flow">Control Flow</h2>
<p>Here is where you would discuss <code>step.jump</code> and the function index.</p>
</div>

</div></body>
<!-- todo: move into an edify plugin -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-20388260-3', 'bigeasy.github.io');
ga('send', 'pageview');
</script>
</html>
