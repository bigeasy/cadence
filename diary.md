# Design

[Merlin Mann](http://youlooknicetoday.com/) writes about time and attention and
creative work. His thesis is that if you give your time and attention to any
endeavour, you are rewarded with insights into your endeavour. Give it your time
and attention and it will give you direction. Take the direction.

There is a corollary, that when you're compelled to give your time and attention
to an aspect of your endeavour that is not at the heart of your endeavour, those
insights still come, although you don't want to hear from them, since these
insights merely distract you from where you ought to be focused. But these
insights start to nag you, they hound you with direction, they bombard you with
clarity, until you finally succumb to the nagging, and the hounding, and
bombardment, and set out to codify your insights in code.

This is why there are so many unit test frameworks. Not because we really need
another one, but because it's something you spend so much time with, you want to
have a place to capture your own experience with this huge, cross-cutting aspect
of your practice. How does a programmer capture his experience? In code.

It is the programmer's variation of the Rifleman's Prayer: This is my unit
testing framework. There are many like it, but this one is mine.

A JavaScript developer is going to spend a lot of time considering the control
flow given the prevalence of callbacks in JavaScript programming. I am such a
JavaScript developer. The more I work with JavaScript, the more I think about
how to work with copious callbacks, the more I want to codify those thoughts in
a library that does what I feel the existing libraries don't.

Oddly, I was very happy using language extensions to make callbacks go away, but
libraries that are not pure JavaScript suffer for adoption in Node.js.
Converting these libraries to pure JavaScript meant a callback explosion.

I've given control flow more than enough time and attention now, especially in
navigating the many tiny evented steps in
[Strata](https://github.com/bigeasy/strata), that I'd like to have a place to
explore the insights. That would be this project.

Which is why Cadence is a curse of insight. It's not that I'm confident that I
have a better solution than those that exist. There appears to be room for
improvement, but that could simply be an assumption that comes from frustration,
one that could be entirely ungrounded. If there is room for improvement, I'm not
confident that I'll find that room or know what to do once I'm in it.

## Concerns Needing Decisions

From the above are the following questions...

 * Do you want to provide a default error handler for a cadence? (No.)
 * What is the correct behavior of the default invocation?
 * What became of your changes for events? (Found 'em!)
 * Can I jump to a place in a parent?
 * Can I have fixups in callback invocations?
 * Why not use arrays explicitly for returns?
 * What could we do with `new step()`?

Decisions...

 * You are more than welcome to annotate the functions generated by step so that
 you can identify them, you are able to identify a Cadence.
 * You cannot use size as metric with syntax bashing. You need space to
 experiment.

## A Bunch of Unrecorded Decisions

It is not my intention at the time of this commit to back fill the decisions
I've already made, I'm primarily interested in working through the decisions
that I've not been able to make through noodling alone.

 * Use of `_` before a callback to indicate that function takes no arguments.
 * How we're not that concerned about events that may or may not happen.

Super important that the common cases require less punctuation, even if it ruins
the consistency. Key here is `step(function () {});` to create a sub-cadence,
without having to deal with a return value.

This...

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step());

  }, function (body) {

    console.log(body.split(/\n/).length);

  });
});
```

Not this...

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step());

  }, function (body) {

    console.log(body.split(/\n/).length);

  })(); // NO!
});
```

Whenever I've done that, I've hated it and forgot the invocation anyway.

Here's a couple ideas...

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step());

  }, function (body) {

    console.log(body.split(/\n/).length);

  }).happy('happy').joy('joy')
    .inscrubulate(2.2219, require('underscore'), 1 + 1 === 4)
    .invoke('roger all systems go')
    .oh('I forgot to say...').please();
});
```

...that make me want to cry. No method chaining. No. Method. Chaining.

## The Cadence Beastiary

Cadence uses an function named `step` that is a magic function; if you call it
with different sorts of parameters, it will behave differently.

What sorts of parameters can we use with step? That is something to layout when
designing the API that will use step; a list of the different beasties that we
can give to step, so we can assign a meaning to each beastie. Look for my

```javascript
cadence(function (step) {

  step();           // arguments.length == 0;
  step([]);         // Array.isArray(arguments[0]);
  step({});         // typeof arguments[0] == "object"
  step('');         // typeof arguments[0] == "string"
  step('a');        // /^a$/.test(arguments[0]);
  step(1);          // !isNaN(parseInt(arguments[0], 10)) && isFinite(arguments[0]);
  step(null);       // arguments[0] === null;
  step(this);       // arguments[0] === this;
  step(step);       // arguments[0] === step;
  step(cadence);    // arguments[0] === cadence;
  step(/example/);  // arguments[0] instanceof RegExp

  step(named);      // Named function, see sub-cadences below.

  step(Error);              // arguments[0] === Error
  step(new Error);          // arguments[0] instanceof Error
  step(new EventEmitter);   // typeof arguments[0].on == "function"

  // Sub-cadences.
  // arguments.every(function (a) { return typeof a == 'function' });
  step(function (value, step) {

    // In the above step will terminate the function list.

  }, function named () {

    // We can have named functions that appear in the context.

  }, function _ (value, name) {

    // We can have special names, or decorators, that change interpretation of
    // the signature.

  }, function name$flag$option (value, name) {

    // We could use a special character to denote flags.

  }, function name$ig (value, name) {

    // Or, like regular expressions, we can have single character switches.

  }, function ($name, value) {

    // Currently, starting with a `$` means we want to get the value, but we
    // don't want it to be kept in context.

  }, function (named) {

    // We can reference functions named in the cadence and jump too them.
    if (1 == 1) fs.readdir(".", step(named));
    else step(named)(null, []);

  }, function (_) {

    // This still exists to support Streamline.js.

  }, function (callback) {

    // Create an old-fashioned callback, but maybe this is generalized.

  }, [function () {

    // Wrap a function in an array to mean something special.

  }], [function () {

    // try

  }, function (error, errors) {

    // catch

  }], [false, function (value) {

    // if not false exit early, otherwise send value onward.
    return !! value

  }], [/expected/, function () {

    // if not matching regular expresison or exit early.

  }], [function () {

    // any condition to leave.

  }, step(function () {

    // a cadeence to run if we're not leaving.

  }, function () {

    // and so on

  })], function () {

    // Using the beastiary, what about nested?
    var label = step(function () {
        if (Date.now() % 2) return [ label, 0 ]
        fn(step())
    }, function (value) {
        return [ value + 1 ]
    })

    // Loops stay, but gathered is an empty leading array.
    step([], function (number) {
        return [ number ]
    })(5)


    // End of step fixup. Nmonic, well, we use `[ step ]` to exit so we can use
    // `step(step, function () {})` to append.

    step(step, [function () {}])

    // I never use this.

    var arrayed = step([])

    var arrayed = step([], function (item) {
        return [ item ]
    })

    // Each invocation appends to the generated array.

    arrayed(1)

    // So you can easily do this.

    array.forEach(step([], function (item) {
        return [ item * 2 ]
    }))

    // Fixups are rare, but they are nice, currently.
    db.open(step(step, [function (db) { db.close(step())   }]))

    // Turn a sub-cadence into a fixup by invoking it with `step`?
    db.open(step([function (db) {
        db.close(step())
    }], function () {
        db.pooling = true
    })(step))

    // Turn a sub-cadence into a fixup by creating a callbak by passing it to
    // `step`?
    db.open(step(step([function (db) {
        db.close(step())
    }], function () {
        db.pooling = true
    })))

    // Other constuctions.
    step(step)(function () {
    })

    // Construction options.

    step([function () {}]) // Treat as special case finalizer.
    step(step, function () {})
    step(step(function () {}))
    step(function () {})(step)
    step(step)(function () {})

    // Follow up, mnemonic: a cadence that runs after this step completes, which
    // is why it comes after `step` its declartion.
    step(step)(function () {})

    // Follow up, mnemonic: hmm... same as above, this step, followed by.
    step(step, function () {})

    // Looks like this, break after step, so insert into step.
    return [ step, 1 ]

    // Fixup: mnemonic: no good mnemonic, but it looks functiony, maybe one step
    // inside another shows that this is something to do later.
    step(step)(function () {})

    // Fixup: you want to filter it somehow, I know, horrible.
    step(/./, function () {})

    // All around bad, because parens after a cadence start a loop.
    step(function () {})(step)


    // Other options, extensibility.
    step(on, ee)('data', [])
    step(on, ee)('end')
    step(on, ee)(Error)

    // Now that I have `null` back, `null` can mean no error, so we can keep
    // shifted event handlers.
    ee.on('data', step(null, []))
    ee.on('end', step(null))
    ee.on('error', step(Error))
  });

  // Signatures.

  // Mix or match.
  step([0]);
  step([step]); // I might want this to mean gather.
  step({ $trigger: 3 });
});
```

In the beastiary we can detect an empty argument list, we can have the length of
the arguments mean something; if we pass a number and a string, the number could
be the number of times we print the string, but if we pass just a number, then
it could mean the number of seconds to wait before exiting. Nonsense example,
but you get the picture.

In the case of objects, for JavaScript objects, we can pass in the constructor
function, so `Error` could be used to indicate something about error handling.
We can accommodate Node.js special cases with duck typing, we can identify event
emitting objects using configurable duck typing so that cadence can discover
event emitting objects in frameworks outside of Node.js.

I require that the caller gives us an actual type, that it doesn't trigger any
of the [typing
pitfalls](http://webreflection.blogspot.ie/2012/06/javascript-typeof-operator-problem.html).
About those I simply do not care. Those are "Doctor it hurts when I do this."
problems, problems that a latched onto by those looking to be Nerd Perfect(tm).

Not only can we accept strings, but we can run regular expressions against
strings so that they have different meanings.

Currently, assignments are...

 * Arrays of functions are sub-cadences.
 * Integers indicate arity.
 * An array indicates an array of responses.
 * Order of invocations of step establish the order of arguments to subsequent
 functions.

Arrays of functions are sub-cadences.

## Sub-Cadence as Callback?

Curious, found a great usage for a sub-cadence as callback. Here's where the
cracks of the convention may be filled, so...

## Inhabiting the Cracks in Convention

In a callback of the following form, the `error` is supposed to be an `Error`
object by convention.

```javascript
function (error, result) {
}
```

When it is not an error object, it can be an indicator that the callback is
supposed to do something else.

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step());

  }, function (body) {

    console.log(body.split(/\n/).length);

  });
});
```

In the above, `step()` creates the callback invoked by `readFile`.

```javascript
cadence(function (step) {
  step(function () {

    var splitter = step();
    fs.readFile(__filename, "utf8", splitter(function (body) { return body.split(/\n/) }));

  }, function (lines) {

    console.log(lines.length);

  });
});
```

In the above, we create a callback then create a wrapper, when our callback gets
a function as it's first argument, it knows that it is going to run a
sub-cadence against the result.

This collides with the use of sub-cadences with `forEach` below.

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step()(function (body) { return body.split(/\n/) }));

  }, function (lines) {

    console.log(lines.length);

  });
});
```

The assumption here is that in ordinary operation, no one is going to call us
back with `typeof error === "function"`, but they could, I suppose, if they
really wanted to.

We could be more explicit, using one of our special variables.

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step()(step, function (body) { return body.split(/\n/) }));

  }, function (lines) {

    console.log(lines.length);

  });
});
```

Which would be awful hard for anyone to abuse us with.

Ah, but then, why not...

```javascript
cadence(function (step) {
  step(function () {

    fs.readFile(__filename, "utf8", step(step, function (body) { return body.split(/\n/) }));

  }, function (lines) {

    console.log(lines.length);

  });
});
```

This reads to me as, create a `step` callback, but run this sub-cadence against
the response, here's a sub-cadence in a callback, i.e. `step(step`.

Now we can address the problem of a callback that might not be called, this
imaginary creature, something I've yet to see in the wild...

```javascript
cadence(function (thing) {
  step(function () {

    thing.happensWhenDone(step());
    thing.mayOrMayNotHappen(step(step, []));

  }, function (definately, maybe) {

    console.log(definately, maybe.length);

  });
})(require("thing"));
```

Looks like I'm not going to make use of an overloaded `error`.

## Order and Arity of Subsequent Functions

It appears that there would be a common case when working with `fs` where you'd
want to invoke a callback for a list of items, gathering the results into a list
for further processing, or even running them through a pipeline. It is difficult
to imagine how far one needs to take parallelism at this point, but I keep using
the example of descending a directory with the Node.js `fs` package when
considering how to facilitate this operation with Cadence.

Currently, I'm trying to determine how to specify the order of the arguments
passed to the subsequent function in the cadence.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      listing.forEach(function (file) {
        fs.stat(file, step());
      });

    }, function (stats, listing) {

      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', step());
        }
      });

    }, function (bodies) {

      if (bodies.length) {
        process.stdout.write(bodies.concat([ '' ]).join('\n'));
      }

    });;

})(".", +(new Date) - 1000 * 60 * 10);
```

The problem with the above is this; what happens if `step()` is not called? In
the case of the listing, the target directory might be empty. In the case of the
modified time, there may be no newer files.

The signature of the subsequent function is determined by the arguments in the
callback to function generated by `step()`. If step is not called because of an
empty set, then the signature of the subsequent function changes.

We're not going to see the worst of the change in this case. If the listing is
empty, then the stats argument to the subsequent function is `null`. This is not
unreasonable, but it means we have to check for `null` instead of calling
`forEach` on a zero length array. However, in a case where we're looping,
jumping to a previous point in the cadence, we'd read the current value of
`listing`, it would not be overwritten.

The type change is enough of an annoyance. If the callback to `step()` is not
called, there is no value to set parameter in the subsequent signature, but
there a problem if it is called only once, since we don't know if we should
expect more calls. In many instances, we only expect there to be a single
invocation of the `step()` callback. In these cases, we want a scalar value.


```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, step) {

  fs.readFile(path, 'utf8', step());

}, function (body) {

  process.stdout.write(body);

})(__filename);
```

In the above example, we do not want an array of one file body, we want the one
file body as a scalar variable. In our directory listing code, however, we might
have a directory that has only one entry. Thus, `step()` is called only once,
which could mean scalar, or it could mean an array.

We're leaning toward getting around the array problem by declaring an array type
in the call to step by passing an empty array.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      listing.forEach(function (file) {
        fs.stat(file, step([]));
      });

    }, function (stats, listing) {

      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', step([]));
        }
      });

    }, function (bodies) {

      if (bodies.length) {
        process.stdout.write(bodies.concat([ '' ]).join('\n'));
      }

    });;

})(".", +(new Date()) - 1000 * 60 * 10);
```

This solves the problem of differentiating from scalar and array, but it does
not solve the problem of an empty listing. If `step()` is not called, there is
no indication to Cadence that a value is expected.

To solve this, I moved to having a declaration of an array.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      var stats = step([]);
      listing.forEach(function (file) { fs.stat(file, stats()); });

    }, function (stats, listing) {

      var bodies = step([]);
      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', bodies());
        }
      });

    }, function (bodies) {

      if (bodies.length) {
        process.stdout.write(bodies.concat([ '' ]).join('\n'));
      }

    });;

})(".", +(new Date()) - 1000 * 60 * 10);
```

Along the way, were were some incantations. Starting with having `step([])`
generate a callback.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      var stats = step([listing.length]);
      listing.forEach(function (file) { fs.stat(file, stats); });

    }, function (stats, listing) {

      var bodies = step([]);
      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', bodies(1));
        }
      });

    }, function (bodies) {

      if (bodies.length) {
        process.stdout.write(bodies.concat([ '' ]).join('\n'));
      }

    });;

})(".", +(new Date()) - 1000 * 60 * 10);
```

In the above, we put a numeric value in the array to indicate that that step
function will have that many callbacks. In the case of stats, we know already
how many stats we're supposed to have, so we can declare our `stats` callback
with a callback count.

Except now we don't know the index of callback. In our solution before this one,
when we call `stat()`, we know that the callback will append to the array at the
current length of the array, each invocation adds an element. With this
solution, we'd have to add our answers as they arrive, no indication of the
index. Breakage one.

If the order didn't matter, then this would be fine, but it will, almost
always, because parallel arrays is what we do.

Next we'd overload the `error` of the callback to look for a count. When the
array is specified without a count, it will not count on anything to return. We
need to tell it to wait by invoking the callback with a count to increment the
number of times we're supposed to wait. If we didn't like overloading the return
value, then we run it through `step`.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      var stats = step([listing.length]);
      listing.forEach(function (file) { fs.stat(file, stats); });

    }, function (stats, listing) {

      var bodies = step([]);
      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', step(bodies, 1));
        }
      });

    }, function (bodies) {

      if (bodies.length) {
        process.stdout.write(bodies.concat([ '' ]).join('\n'));
      }

    });;

})(".", +(new Date()) - 1000 * 60 * 10);
```

I don't see a second breakage, but I like the notion of being explicit in
calling these. I can't imagine a case of using an `error` callback where things
might not happen. We looked at using `step` to create  callbacks above, but I
imagine that when we have the zero to many issue arise with callbacks, we could
so something like the following.

```javascript
step(function (thing) {

  var items = step([]);
  thing.mayOrMayNotCall(function (error, result) {
    items()(error, result);
  });
  thing.willCallWhenDone(step());

}, step (items, done) {

  console.log({ items: items, done: done });

});
```

Not bad and for the uncommon case.

Now getting back to the solution we settled on, we're losing track of the
details of our bodies, so can use an inner cadence, a cooking cadence, to gather
up our data into an object.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (path, since, step) {

    step(function () {

      fs.readdir(path, step());

    }, function (listing) {

      var stats = step([]);
      listing.forEach(function (file) { fs.stat(file, stats()); });

    }, function (stats, listing) {

      var bodies = step([]);
      stats.forEach(function (stat, index) {
        if (stat.mtime > since) {
          fs.readFile(listing[index], 'utf8', bodies(step, function (body) {
            return {
              name: listing[index],
              stat: stat,
              body: body
            }
          }));
        }
      });

    }, function (files) {

      if (files.length) {
        files.forEach(function (file) {
          console.log("file: " + file.name + ", size: "  + file.stat.size + ", first line:");
          console.log(file.body.split(/\n/).shift() + "\n");
        });
      }

    });;

})(".", +(new Date()) - 1000 * 60 * 10);
```

Having delved into the implementation, I now see a pattern that can be reused
across steps, sub-cadences and fix-up cadences.


```javascript
step(function (thing) {

  var items = step([])([]);
  thing.mayOrMayNotCall(items);
  thing.willCallWhenDone(step());

}, step (items, done) {

  console.log({ items: items, done: done });

});
```

Simply have the callback generator function be the one to determine if the
callback it generates is definite or zero to many.

```javascript
step(function (ee) {

  ee.on('error', step([], 0)([]);
  ee.on('done', step(2));
  ee.on('data', step([])([], null));

}, step (code, signal, data) {

  console.log({ code: code, signal: signal, data: data });

});
```

In the above, the second array means that it is a zero to many event, while the
null means that the error is always `null`, or shift the error. We could have
`-1` mean shift the error.

The error handler has an `arity` of zero, so it doesn't get added to the
signature of the subsequent function.

We could also pass in `Error` to indicate an error handler.

We might even be able to have a way to express a scalar that may or may not
happen, but I don't see it here. Still isn't anything I've encountered in the
while except for the error handler. Usually if it may or many not happen, it may
or may not also happen twice.

## Sub-Cadences

I need to go and back fill, here, but there are ways in which I expect Cadence
to work, such as, when the `step` function is used to create a sub-cadence, that
sub-cadence will produce a result that will appear in the parameters passed to
the subsequent function.

Let's way we want to gather up the file contents and file meta data for an
entire directory.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step(function () {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(function (file) {
        step(function () {

          fs.stat(path.join(directory, file), step());

        }, function (stat) {

          fs.readFile(path.join(directory, file), step());

        }, function (body, stat) {

          return { name: file, stat: stat, body: body };

        });
      });

    }, function (objects) {

      // Superfluous step here. It would have been returned from the previous
      // function out to the caller.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

It is my intent that the above would create an array of objects containing the
file name, status, and contents of each file.

Unlike a callback declaration, a declaration of a sub-cadence does not produce a
new parameter in the subsequent function. For each declaration of a callback, a
new parameter is added to the subsequent function, but a sub-cadence will always
gather up its results into an array.

Why? Okay. Here's the same problem. If there are no entries in the directory,
then the sub-cadence declaration will not be invoked. If it is not invoked, then
we don't know to expect it. The `objects` value (superfluous since it will be
returned up through to the caller) will be either an array or null. I need to
declare that step.

The outer step is simple enough. It is declared once, so we know that it will
return a scalar, like a callback `step` invocation.

The problem is now that we've created this sub-cadence that need to be declared
outside of our for each loop, but we need to define our functions using the
closure that will capture the `file`.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step(function () {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(step([], function (file) {

        fs.stat(path.join(directory, file), step());

      }, function (stat, file) {

        fs.readFile(path.join(directory, file), step());

      }, function (body, stat, file) {

        return { name: file, stat: stat, body: body };

      }));

    }, function (objects) {

      // Superfluous step here. It would have been returned from the previous
      // function out to the caller.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

The above solution would be to have our `step` sub-cadence invocation return a
function that constructs a step each time it is called. The initial array
parameter tells `step` that this is arrayed, it builds a function that will feed
it's arguments into the first step of the cadence.

This invocation of step will strip arity and type arguments off of the front of
the argument list, the presence of one or more functions thereafter indicates
that the invocation is a sub-cadence.

However, in our above example, it could be the case that some of the files in
the directory are other directories.

Each file needs a call to `stat`, but not all of
them will go onto `readFile`. I can see a solution that works with an object in
a scope outside of the inner cadence.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    var objects = [];

    step(function () {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(function (file) {

        step(function () {

          fs.stat(path.join(directory, file), step());

        }, function (stat, file) {

          if (!stat.isDirectory()) {

            step(function () {

              fs.readFile(path.join(directory, file), step());

            }, function (body, stat, file) {

              objects.push({ name: file, stat: stat, body: body });

            })

          });

      });

    }, function _() {

      // Ignore return and return our objects array.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

Not that much different from a hoisted function solution. What would actually go
inside the inner loop that

Each call to step indicates both a callback and a spot in the array. How do we
separate the callback from the spot in the array?

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step(function () {

      fs.readdir(directory, step());

    }, function (files, step) {

      var objects = step([], function (body, stat, file) {

        return { name: file, stat: stat, body: body };

      });

      var stats = step([], function (file) {

        fs.stat(path.join(directory, file), step());

      }, function (stat, file) {

        if (stat.isDirectory()) fs.readFile(path.join(directory, file), objects(file));

      }, function _(stat) {

        return stat;

      });


      files.forEach(function (file) {
        stats(file);
      });

    }, function (objects) {

      // Superfluous step here. It would have been returned from the previous
      // function out to the caller.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

The above solution would use fact that `objects` is declared before `stats` to
establish the order of parameters to the subsequent function. Each call to stats
causes Cadence to wait for a return, but the sub-cadence would invoke the
objects sub-cadence, which would schedule an additional return and create space
in the objects array.

At the end of the stat sub-cadence is a return that ensure that we always return
something from the stat sub-cadence, even though we don't use it. This would
probably be the case most of the time, making this an invitation to busy work,
or comments along the lines of, "we don't need the return value so we don't
worry if this returns undefined."

This design would be nightmarish, but it helps to flesh out alternatives,
because until I'm able to see how bad it is, it is going to nag. I suppose this
is meta and about the design process, but when I'm holding this in my head, I
will think of this again, what if you composed sub-cadences? What if one
sub-cadence called another, so you could use the same ordering logic? Then I have
to think about it, realize that it doesn't look or read right, then wait a day
or two and think, what if you composed sub-cadences? What if one sub-cadence
called another, so you could use the same ordering logic?

It is good to have a catalog of what was said by the voices you heard calling
you into dark alleys.

Here's let's experiment with the concept of an early return, which is an
undocumented decision, but one that is still implemented.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step(function () {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(step([], function (file) {

        fs.stat(path.join(directory, file), step());

      }, function (stat, file) {

        if (stat.isDirectory()) step(null);
        else fs.readFile(path.join(directory, file), step());

      }, function (body, stat, file) {

        return { name: file, stat: stat, body: body };

      }));

    }, function (objects) {

      // Superfluous step here. It would have been returned from the previous
      // function out to the caller.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

When you call step with either `null` or an `Error` as the first argument, the
cadence will return immediately and not continue with the next step. If the
first argument is an `Error`, then the cadence ends immediately with `Error` as
the error result. If the first argument is `null`, it is as if you were invoking
a callback, `null` indicates no error, what follows is the return value for the
callback.

When the early exit is invoked with no additional arguments, we'll interpret
that to mean that no return value is provided, and therefore the element should
be eliminated from the result set.

From the bestiary, at this point in the design, we could use a different
indicator to indicate an early return such as `step(this)` or `step(step)`, but
upon some reflection, that is no shorter than `step(null)`. However, if we end
up wanting `null` to mean something else, such as a scalar event that may not be
triggered, we might have to use `null` for that purpose.

However, if that is the case, one can use an array, and check the array length,
or if they really want `undefined`, they can call `shift` and see what they get.

The semantics of using an array in that case would have to be super annoying and
the use case would have to be super common, but I can't even imagine an example
of a scalar event that might not happen other than `error`, and I've got `error`
covered.

While we're looking  at this, let's consider how far we can nest cadences.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step(function () {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(step([], function (file) {

        var resolved = path.join(directory, file);

        step(function () {

          fs.stat(resolved, step());

        }, function (stat, file) {

          if (stat.isDirectory()) step(null);
          else fs.readFile(resolved, step());

        }, function (body, stat, file) {

          return { name: file, stat: stat, body: body };

        });

      }));

    }, function (objects) {

      // Superfluous step here. It would have been returned from the previous
      // function out to the caller.

      return objects;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

It would appear that the early return would work here as well. The return
would propagate to the outer function.

## Looping

Our sub-cadence example likes to run in parallel, let's slow it down a bit with
looping.

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    var objects = [];

    step(function () {

        fs.readdir(directory, step());

    }, function next (files, step) {

      if (files.length()) return files.shift();
      else step(null, objects);

    }, function (file) {

        var resolved = path.join(directory, file);

        step(function () {

          fs.stat(resolved, step());

        }, function (stat, file) {

          if (stat.isDirectory()) step(null);
          else fs.readFile(resolved, step());

        }, function (body, stat, file) {

          objects.push( { name: file, stat: stat, body: body });
          step(next)(null);

        });
      }
    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

As you can see, we had to go back to building our own objects array, which kind
of fits with the notion of looping, as opposed to the recursion that comes from
for each.

Looping can be invoked as a callback too, obviously. In the above example I'm
invoking the callback generated by step immediately to jump, but it could be
given as a callback to an asynchronous function.

*UPDATE*: Had a thought...

```javascript
cadence(function (step, iterator) {
  step(function () {
      iterator.next(step(false))
  }, function (value) {
      console.log(value)
  })()
})
```

In the above, the terminal condition is when the return value is falsey. We've
not had a use for the boolean yet.

*UPDATE*: *TODO* Had another thought...

```javascript
cadence(function (step, iterator) {
  step(function () {
      iterator.next(step(false, 10))
  }, [])()
})
```

The above would exit while the condition is not ten. Also, while I'm at it...

```javascript
cadence(function (step, iterator) {
  step(function () {
      iterator.next(step(false, 10))
  }, [])()
})
```

An array as the last argument, that could mean gather.

Also, there's a `break` in here somewhere.

## Events

With so much sorted out, events ought to get easier.

```javascript
var cadence = require('cadence')(function (object, step) {
  if (object.on && object.stdout && object.stderr) {
    // Magic.
  }
});

cadence(function () {

  step(function () {

    var prog = spwan('chatty', []);

    // Hummm... Use an array to make things look like Objective-C for
    //          no good reason?
    step([prog, 'exit'], 2); // Need to specify arity.
    step([prog, 'error'], 2); // 'error' is special
    step([prog.stdout, 'data', []]);
    step([prog.stderr, 'data', []]);

    // Hermm... Use `this` to mean object based?
    prog.on('exit', step(this, 2));
    prog.on('error', step(this, 'error'));
    prog.stdout.on('data', step(this, []));
    prog.stderr.on('data', step(this, []);

    // Erp... All errors at once?
    step(this, 'error', prog, prog.stdout, prog.stderr);

    // Custom handlers?
    step(this, spawn);

    // Argh... What do we have left in the beastiary?
    var on = step(prog, prog.on);
    on('exit', 2);
    on('error', 'error');

    // Create a callback builder?
    var on = step(this, 'on');
    on(prog, 'exit', 2);
    on(prog.stdout, 'data', []);
    on(prog.stderr, 'data', [], function (data) {
      return data.map(function (buffer) { return buffer.toString() }).join('');
    });
    // Objects first, then action, then definition. ('error' is special.)
    on(prog, prog.stdout, prog.stderr, 'error');

    // Same, but no auto call.
    var event = step(this);
    prog.on('exit', event(2));
    prog.stdout.on('data', event([]));
    prog.stderr.on('data', event([], function (data) {
      return data.map(function (buffer) { return buffer.toString() }).join('');
    }));
    // Then this gets monotonous.
    prog.on('error', event('error'));
    prog.stdout.on('error', event('error'));
    prog.stderr.on('error', event('error'));

  }, function (code, signal, stdout, stderr) {

    stdout = stdout.map(function (buffer) { return buffer.toString() }).join('');
    console.log(code, signal, stdout, stderr);

  });

});
```

Okay, it's not easier. What needs to happen is that the first argument to a
callback is shifted. Events will have events that do not get called, here might
be more of a concept of null events, as opposed to definite events versus zero
to many events.

The notion of giving the user an interceptor is one way to go, but why use an
interceptor when you can just use functional composition?

Instead of...

```javascript
var cadence = require('cadence')(function (object, step) {
  if (object.on && object.stdout && object.stderr) {
    // Magic.
  }
});
```

Why not?

```javascript
function stdio (step, program) {
  program.on('close', step(2));
  program.stderr.on('data', step([]));
  program.stdout.on('data', step([]));

  var caught = step(0, [], [])
  program.on('error', caught);
  program.stdout.on('error', caught);
  program.stderr.on('error', caught);

  return program;
}

cadence(function () {

  step(function () {
    stdio(step, spwan('chatty', []));
  }, function (code, signal, stderr, stdout) {
  });

});
```

New problem to solve; no way to catch errors that might not occur. We were only
going to do scalar errors, so now I suppose we will do array errors, but we'll
only exit on the first one.

Bletch. Everything everywhere is a stream forever. I suppose, before I can
consider how to capture event emitter problems, I need to find a language to say
that we want to shift the result, or that there will be no error.

```javascript
ee.on('drain', step(null));
```

Where `null` means that the error is always null. I keep thinking that I could
go a path where we want to imply what we're starting variable argument list, and
the rest of the results should be catenated, but I don't like the idea, because
it is generalization for a specific case.

Actually, could  this construct be a way to pass additional information to the
next function?

```javascript
cadence(function (step) {
  step(function () {
    ee.on('drain', step([null, +(new Date)]));
  }, function (time) {
    return time;
  });
});
```

No good reason to do that, though. You could just as easily add a variable to
the enclosing scope.

Addendum...

For events, I'm wondering if there isn't a way of externalizing the function?

```javascript
cadence(function (step, ee) {
  var event = step(Array.prototype.shift); // It can be verbose!
  step(function () {
    ee.on('exit', event());
    ee.stdout.on('data', event([]));
    ee.stderr.on('data', event([]));
    event('on', 'error', [])(ee, ee.stdout, ee.stderr);
  }, function (code, signal, stdout, stderr) {
    return !signal && code == 0;
  });
});
```

That doesn't look as bad. The special event function wraps the call to `step`
and can be used anywhere. Like `step` it is a constructor function.

## Reentrancy

Something like this, where `sub` is called and a new state is created. The
return values here are not correct; I'm not sure what it is building, but the
call to sub, well how is that different from out looping construct?

Grr...

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step({ directory: directory, parent: {} });

    step(function sub (directory) {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(step([], function (file) {

        var resolved = path.join(directory, file);

        step(function () {

          fs.stat(resolved, step());

        }, function (stat, file, sub) {

          if (stat.isDirectory()) step(sub)(step());
          else fs.readFile(resolved, step());

        }, function (body, stat, file) {

          return { name: file, stat: stat, content: body };

        });

      }));

    }, function (entries, parent) {

      parent.entries = entries;
      return parent;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

Okay, how about this then?

```javascript
var fs = require('fs'), cadence = require('cadence');

cadence(function (directory, since, step) {

    step({ directory: directory, parent: {} });

    var descend = step(function sub (directory) {

        fs.readdir(directory, step());

    }, function (files, step) {

      files.forEach(step([], function (file) {

        var resolved = path.join(directory, file);

        step(function () {

          fs.stat(resolved, step());

        }, function (stat, file, sub) {

          if (stat.isDirectory()) step(descend)(step());
          else fs.readFile(resolved, step());

        }, function (body, stat, file) {

          return { name: file, stat: stat, content: body };

        });

      }));

    }, function (entries, parent) {

      parent.entries = entries;
      return parent;

    });

})(".", function (error, results) {
  if (error) throw error;
  console.log(results);
});
```

That would have to just work, creating an entirely new context. So, `step` runs
immediately, but it also creates a callback that can be run subsequently, or at
any time really, possibly even exported from the `cadence` scope.

## Variable Arguments

This is becoming a won't do, I don't see the value in variable arguments. Where
is there a callback that has a variable argument return? If it gets in the way
at all, it goes away.

## The Day After Tomorrow / Minifcation and the Sub-Context

I woke up today and realized, this isn't going to be a MicroJS library, because
it does minify. Once you minify, function parameters get renamed, because they
are not in scope, and your Cadence breaks.

Which isn't covered in this design document, stashing variables in the hidden
context, it's not covered, but it is the magic with which Cadence came to be.

Write my own minifier, of course. Patch UglifyJS to leave the function
declarations alone, but that's never going to happen.

Then I started to consider how it was used. I've begun to use `step` to
create sub-cadences do I don't have to repeat myself, using the enclosed scope
to capture parameters from a step in a cadence in a sub-cadence.

Then, I've begun to be explicit about arity, in declarations, so the special
variables that control arity don't matter anymore. At the same time, I'm passing
in an array to indicate that values should be gathered, that array can be the
array that gathers, so that can be declared at the outer scope and passed in.

Finally, I've already demonstrated in tests here that you can assign a function
to a variable and pass it into a cadence, so jumping still works.

Unfortunately, this really does break Proof, where I've enjoyed the ability to
hit the ground running because I can pull what I need out of this hidden
context, so for the sake of Proof, I suppose the hidden context stays.

Finally, it occurs to me that callbacks can write to the this object, but if
we're building an object, it is not any more or less noxious to me to assign the
variable to an object in scope.

Creating my own minifier, a variation of UglifyJS that would skip functions if
they had a particular name or naming convention, or might possibly look for
`step`, and skip all the functions within it.

**Decision**: Hidden context goes, minification stays. Use variables for named
functions. Airty is determined by the preceding step, not the function signature
of the step.

## Error Handling

What follows are some general questions on error handling, thereafter followed
by my programmers-journal/tear-soaked-diary about error handling.

### What do Node.js Veterans Expect from an Error-First Callback?

The best thing to do is to ask the Node.js community, how do you handle
parallelism within an error-first callback function? What is the current
convention and is it correct?

I'm sure there are a lot of people using
[`require('async').parallel`](http://nodejsreactions.tumblr.com/post/53765515453/require-async-parallel)
and are happy with its behavior; where the result of any error in any parallel
operation is to return the first error, but let the remaining parallel functions
run to completion without calling the callback. If any of the remaining
operations create an error the error is lost.

This is the issue I'm trying to resolve, how do you report parallel errors in
callbacks?

Here is what I believe to be true and universally agreed upon: The error-first
callback convention expects to be called once and only once by the function to
which it is given. If there are two errors it will be unconventional, and most
surprising, for the callback to be called once for each error.

Also universally agreed upon, and almost not worth mentioning, is that `error`
is an `Error` object an not an array of `Error` objects or any other such
nonsense.

When you are running operations in parallel, you could have multiple errors.
Perhaps you're `readFile`ing the files in a directory listing, but you don't
have permission to read those files. In this case, getting the first instance
back will probably give you enough information to solve the problem. *However*,
if, in parallel, you're establishing a database connection and reading a file,
and the network is down and the file is missing, you're only going to get a
partial picture of what is wrong.

Thus, let's put a summary here. When running in parallel within a callback:

 * do you return just the first `Error` or all the `Error`s?
 * how you do you group all the `Error`s, as a property of an umbrella `Error`?
 * how do you know which of your parallel operations raised the `Error`?
 * when a parallel operation fails, do you make a best effort to terminate the
   other operations, or do you let them run to completion?

The caller is expecting an `Error`, not an array of errors. One could create an
umbrella `Error` object and have a `parallelErrors` property that is an array
member but, another belief of mine is that people are going to
`if`&nbsp;`(error)`&nbsp;`throw`&nbsp;`error` and they expect that error to have a
meaningful message. If you have a library like `async` doing your parallelism,
you're going to have to also provide an error message to the `parallel` call to
add to the umbrella `Error`, otherwise the best it can surmise is
`"something`&nbsp;`bad`&nbsp;`happened"`.

Furthermore, getting back an exception of this sort requires navigating the tree
structure that it would create, this `Error` is really a collection of `Error`s
so let's loop through that, and, oh, look, one of `Error`s is also an umbrella
`Error` so let's recurse.

Finally, gathering up `Error`s from parallel operations adds the question of
how to match the `Error` with the operation, if that is something that is at all
necessary. `Error` objects usually have a little bit of context, plus their
stack trace. If you're propagating an `Error`, not handling it within the
parallel operation that raised it, it's usually for the sake of logging, not to
use the `Error` to answer all your questions.

I'm sure you'll say that this is why we have `EventEmitter`, which probably
suggests that reporting only the first error makes the most sense, but
`async.parallel` exists, so what else does one have to consider when they use
it. What of those swallowed `Error`s?

### End Transmission

You can stop reading now. This is what are some things that occur to me.

Cadence will make serial callback operations parallel, so I have the additional
question of whether or not those should run to completion.

Any step can easily run parallel operations, all you need to do is create more
than one step function, so this is a problem that is everywhere in Cadence. It
becomes unpleasant to say that an error handler in Cadence will infer
parallelism, because then we're talking about arrays of errors everywhere we go.

Thus, I can say that Cadence **encourages parallelism**, which is why this is
such a problem for me. Without the parallelism, these operations would take
place in serial. If it were serial, if you weren't using Cadence, you'd only get
the failed database connection, because you wouldn't get to the point where the
file is opened.

Okay, but now you have an open file but an error has occurred. Does Cadence need
some sort of a `finally` construct? (`step` could return a cleanup cadence, add
to a sub-cadence, in scope, gets called last.)

Hmm... Arrays of errors and encouraged parallelism. Internal to Cadence, errors
are arrays of errors.

```javascript
cadence(function () {
  var db, fd;
  step(function () {
    step(function () {
      // ... a cadence that opens a database and a file handle ...
    });
  }, function (errors, result) {
    step(function () {
      if (db) db.close(step());
    }, function () {
      if (fd) fs.close(fd, step());
    }, function () {
      if (errors) throw errors[0];
      return result;
    });
  });
});
```

Or, better still, using a funnel.

```javascript
cadence(function () {
  step(function () {
    db.open(step(Error));
    fs.open('config.json', step(Error));
  }, function (errors, db, fd) {
    // This?
    step(errors, function () {
    }, function () {
      // here we shut down...
    });
    // Or this?
    if (errors) step()(errors, db, fd, null); // prepetuate?
    else step(function () {
      // ...do stuff with handles...
    });
  }, function (errors, db, fd, result) {
    step(function () {
      if (db) db.close(step());
    }, function () {
      if (fd) fs.close(fd, step());
    }, function () {
      if (errors) throw errors[0];
      return result;
    });
  });
});
```

What about a janitor?

```javascript
cadence(function () {
  step(function () {
    db.open(step(Error));
    fs.open('config.json', step(Error));
  }, function (errors, db, fd) {
    step.cleanup(function () {
      if (db) db.close(step());
      if (fd) fs.close(fd, step());
    });
    if (errors) throw errors[0];
    step(function () {
      // ... do what you want, the jantor is invoked when all the steps
      // in the step that created it finish.
    });
  });
```

Here the error handling callback gets errors *and* results. The errors are in an
array, because we encourage parallelism, so we want to expose all of the
parallelism to you, so you can decide how to expose it to your callers. Maybe
you do want a tree of errors, or maybe you have an event emitter somewhere that
you can feed errors to.

Here's how you could build your own tree of error.

```javascript
cadence(function () {
  step(Error, function () {
    // ... huge cadence.
  });
}, function (errors) {
  var error = new Error('much bad happened');
  error.errors = errors;
  throw error;
});
```

Can we make things look like Objective-C?

```javascript
cadence(function () {
  step(Error, function () {
    // ... huge cadence.
  });
}, [Error, function (errors) {
  var error = new Error('much bad happened');
  error.errors = errors;
  throw error;
}]);
```

Or even?

```javascript
cadence(function () {
  step([function () {
    // ... try,
  }, function (errors) {
    // ... catch
    throw errors;
  }]);
});
```

Thus, oh, hey, maybe array-wrapped is also a finalizer?

```javascript
cadence(function () {
  step(function () {
    // Cleanups get caled as long as the step doesn't get an error. Cleanup is
    // called when the cadence is over.
    db.open(step([function (db) { db.close(step()) }]));
    fs.open('config.json', step([function (fd) { fs.close(fd, step()) }]));
  }, function (db, fd) {
    step(function () {
      // ... do what you want, the jantor is invoked when all the steps
      // in the step that created it finish.
    });
  });
```

These are the answers. Challenge to get the errors to propagate all the way up
to the catch block. Also, you can cancel, but cancellation doesn't mean that we
don't run finalizers.

This is a garden of pure ideology. Increase in minified size doesn't matter.

For conditional catches, it first tries the code, if there is no code, it tries
the message, to be specific, specify two.

### Original Ramblings Here

It is the opinion of this programmer that exceptions are for exceptional
conditions, and that each exception should be handled as it occurs, so we don't
have a straight-forward way to gather errors. If something might error, catch
the error immediately.

However, you might disagree with me. You're wrong, of course, I'm sure you have
your reasons. Here's what I got for you.

This is were we're going to use `Error` in the beastiary. If you create an
arrayed response, then you can have the option of passing `Error` to gather up
errors instead of abending immediately.

```javascript
cadence(function (step) {
  var errors = step([])(Error);
  errors(new Error(1));
  errors(new Error(2));
  step()();
}, function (errors) {
  equal(errors.length, 2, "two errors");
})();
```

You, know. No. It's so woolly. Where in the API is a `EventEmitter` that pumps
out errors one after another?

>  Error events are treated as a special case in node. If there is no listener
for it, then the default action is to print a stack trace and exit the program.

So say [the documentation](http://nodejs.org/api/events.html). So shall it be.
You can handle the error, I suppose.

```javascript
cadence(function (step) {
  var errors = []
  step(function () {
    erroneous(step());
  }, function (error) {
    if (error.message == "okay") return 1;
    else throw error;
  }, function (result) {
    console.log(result);
  });
  console.log(errors);
}, function (errors) {
  equal(errors.length, 2, "two errors");
})();
```

Bah, I just don't see it, so it is super hard to care. It gets into a confusing
argument with confused people about [when to use
exceptions](http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/) they  are the high-ceremony components of high-ceremony languages.

I've used them for control flow, to indicate a redirect, which feels like an
exception; stop what you're doing and do something else. They are not meant to
be gathered.

There are applications that produce errors, and warnings, a parser is a perfect
example. When you parse a language, you're liable to encounter errors. Detecting
errors in the parsed language is central to the of the parser. It is not
exceptional. You should not stop and unwind the stack.

Incidentally, the use of `Error` could indicate a subsequent error handler
without having to depend on the name `error` in the function signature, which
would be, I think, the last use case for named parameters outside of convenience
or for the sake of magic.

Getting into using this new Cadence and I'm creating funnels. I invoke two or
more operations in parallel in a step so that the subsequent step can get three
different parameters. This is making the hidden context look less and less
useful, valuable.

Problem is, two or more different parallel responses might produce two or more
errors. Should they all be reported, or just the first one that comes back?
Maybe one error can be handled, while another one cannot; one has a handler
registered, the other has not been flagged for error handling.

An exception thrown from a step function is an especially egregious error. We
caught an exception. That's bad news because our step function is faulty. We
should still probably wait for everything to finish though, but what if a `step`
has been created, but it hasn't been given to a callback function, or worse,
it's been given to a callback function and that function has thrown the
exception? There's a good chance that this function is never going to complete,
so we ought to treat a thrown exception as stack unwinding mayhem. The
subsequent error handling function cannot catch exceptions thrown from the
step function, only called back exceptions. If this is an issue, you can use a
try/catch block, or you could even put things in a sub-cadence.

Errors ought to be scalar. We can gather them up for you, but then you have no
context for reporting them, or handling them. Or maybe we do gather them up for
you, because what else are we going to do, but then it's up to you to figure out
what went wrong, you'll complain, and we'll explain that they need to be scalar.

Hard to say. Might go ahead and only support error handling from scalars, since
an array of errors is something you're going to have to construct yourself, and
report yourself, because there is no facility for reporting multiple errors from
an error, result callback signature, and I don't want to be the man to invent
one.

### Errors Gathered, Why Not?

New thoughts, now that we're getting close do done on this library.

Currently, exception handling is handled by a `thrown` method. It would be
better to pass it on to a subsequent call to invoke, so then this becomes
parameters to the invoke function and the errors are handled there.

It doesn't make sense to have an array of errors, really. We need to abend on
the first exception, allowing any parallel invocations to fail silently.

Although, we might want the opportunity to gather up errors, so if we're coming
off of a funnel, but then how do we know it is a funnel? There is no way to
know, so if you want to handle each exception, creating a list, then do it with
the context that a sub-cadence will give you.

This is the final thoughts on the matter. We can put this in the documentation.

An exception jumps the stack and loses all context. If you need to catch, you
need to catch, and we can't make that any easier.

Maybe there are times when you do want the error first, so that you don't have
to write a separate function, because it's not all that exceptional after all?

```javascript
cadence(function (step, files) {
  var stats = []
  files.forEach(step([], function (file) {
    fs.stat(file, step(Error));
  }, function (error, stat) {
    return { error: error, stat: stat };
  }));
});
```

This might be a better way of handling expected errors.

### Exception Handling

*Note*: This was appended to the end of the document late in the project and
moved back up here with the rest of the error stuff.

Probably need to go over all the places where exceptions can occur. The question
is; does Cadence catch exceptions thrown by callbacks? Should it?

What it shouldn't do is what it does now. It returns multiple errors for a
callback. It needs to either return the first error encountered, or else it
needs to return it's own error that contains a list of caught errors.

Currently, I'm favoring the first one, because exceptions are exceptions. They
are exceptional, they are not supposed to happen. If the file system is full, or
of the network is down, you probably only need a sample of the mess of errors
that would be raised in this condition.

Also, a listing of errors is somewhat arbitrary. In a step where a number of
things are happening, we don't really know or care which one of them failed, do
we? How does the world really work?

My examples keep coming back to the file system, going to though a directory
listing in parallel. It may break at some point, say that a file is read
protected, but the directory listings are occurring in parallel, there may be
many such files. How do we report them? Wait, why do we report them? What can we
do with a detailed report of exceptional conditions? Worse, imagine that we've
called our cadence function recursively, now we might have a tree of exceptional
conditions.

That tree would require an `Error` that wraps other errors, you wouldn't be able
to piggy back, because a Cadence might call a Cadence, who gets to ride
piggyback? How is that structured? Imagine that this builder is called by both
an abending `fs` function and an abending Cadence function. Maybe `fs` comes
first, or maybe it is the Cadence function. Different logic is require for
either.

```javascript
function gotMeAnError (instance, error) {
  if (!instance.firstError) {
    instance.firstError = error;
    error.$errors = [ error ];
  }
}
```

There might be a convoluted data structure to build in the first error, but the
simple way to gather up errors is to do this.

```javascript
function gotMeAnError (instance, error) {
  if (!instance.error) {
    instance.error = new Error("something bad happend");
    instance.error.errors = [ error ];
  } else {
    instance.error.errors.push(error);
  }
}
```

Obvious, but it means that any exception thrown by a function built with Cadence
requires some sort of unwrappering, even if it is serial.

Errors feel like a chink in the armor.

The next thought that if you want to gather up exceptions in a parallel
execution, then that is more than exception handling. You're looking to do more
than handle exceptions, you're really gathering up some diagnostics. That is
part of the work of your function, so explicitly handle those exceptions in your
cadence using `Error`.

Sounds good, but then I imagine that that function would look like, `Error`
everywhere, so then I go back to thinking about gathering a tree of errors.

Except that in my use of Cadence, I've never really wanted to gather up a bunch
of errors into an error ball.

Another thing about the error ball; parallelism, it shouldn't matter much. I
find that I read in parallel, but I funnel into a step to do something drastic,
to make a change. That commit doesn't take place until a parallel read has
completed. I'm not seeing where I need more than the first error. If I do need
all the errors, then I need to perform the operation in serial, not in parallel.

Oh! Oh! Oh!

How about this: `[Error]` and errors are going to be gathered? How about them
apples? You like? Or what if you are doing something in parallel, that means you
get the parallel exception? Um, but `[Error]` that means it gets wrapped and
propagated that way, or it means that an error handler will get all errors in an
array? `[Error, "unable to shave yak"]`. Okay, something, something, but abend
on first error is what we do first, and it ought to stop other cadences, right?
Sub-cadences and parallel cadences, or does it wait for them to finish? Or does
it let them soldier on in obscurity? You can have a root array `canceled` and
set its length to 1 to indicated that it has been canceled; `canceled[0]`.

I can't tell if that matters, to cancel them or to let them run to completion.
There's going to be a case where I'll have file handles open at some point.

It is an example of where there error first callback breaks down, in fact, it is
an example of all the complexities of concurrent programming.

**Naw**, the more I look at the error handling example, the more I like the
structure of it. Adding a error-first callback to the cadence makes it look not
that much different from a plain old callback. The nice thing about the skipped
error function is that each step can do one thing. The next step is to either
deal with the *exception* or else it is to continue along it's merry way.

The signifier `}, function (error) {` can *mean* something, dag-gummit!

**Update**: What about swallowing the error, like when a directory already
exists? Can we not provide function? Or do we ask that the user create a
`ignore` function?

### Error Handling

I'd decided to have a separate function that was called for an error, but
skipped if there was no error. Now I'm leaning toward making it so that `Error`
means that the next step is a standard error handling function, expecting an
error-first callback.

Does this mean that some other sort of callback handler might be used with
Cadence?

It may be easier to document, so say, simply, sometimes you do want a chance to
inspect an error, for an exception of some sort that is acceptable. In that case
you can pass `Error` when defining your callback with `step` and your next step
can be an error-first callback. If you decide you do want to stop on the error,
just throw it.

### Error Propagation

Running into a problem with Strata where if I throw an exception from within
Strata, it is likely to get caught by the `validate`. I've already begun work to
solve this problem here. How do you handle errors that are deeply nested, if
you're using try/catch blocks to to convert exceptions into errors?

In the case of Strata, it can call a user function, the user function raises an
exception, and a `validate` wrapper catches it, but it was not an exception
thrown by Strata. Types don't count because we want to catch an exception not
based on type, but based on boundary. If it is raised in the Strata code, catch
it, otherwise, propagate it. Thus, when we callback, and call out, we need to
indicate the boundary.

This ought to work. You wrap the exit in a try catch, and mark it as throwing,
then if you catch the exception that is currently throwing, you rethrow. If
you're calling internally, that is, let's say you're within Strata, and you call
a function like `get()` a function also used by users, if it wraps it doesn't
matter, because you've also wrapped the callback. It calls the callback. Any
exception is intercepted and in the `validate` wrapper.

I'm beginning to feel that I've put so much so much thought into Cadence, I
don't know why I don't use it to build Strata.

## Prototypes and This

There is room for expansion to add extended `this` support, where an array
indicates the properties into which a value should be written.

```javascript
DataFile.prototype.load = cadence(function (step, name) {
  step(['lines'], function () {
    fs.readFile(name, 'utf8', step(step, function (body) {
      return body.split(/\n/).slice(0, -1);
    }));
  }, function () {
    return this;
  });
});
```

In the above, the array `['lines']` indicates that scalar value should be
written to the `lines` property of the `this` object. The array represents the
arity of the return value. The integer arity is also available separately. Done
this way, a plain string on it's own is still available for use down the road.

If you use `this` in your cadence, then it's up to you to call cadence
correctly. For a while, I imagine that, with this property assignment feature,
one might want to always to have a this object, so that you can maintain state
internally, kind of the way that the hidden context used to. However, I'm not
sure how to test for the absence of a real this object between ordinary mode and
strict mode.

However, if it really matters...

```javascript
var dataNoComments = cadence(function (step, name) {
  step(['lines'], function () {
    fs.readFile(name, 'utf8', step(step, function (body) {
      return body.split(/\n/).slice(0, -1);
    }));
  }, function () {
    return this.lines.reject(/^\s*#/);
  });
});

dataNoComments.call({}, path.join(__dirname + 'data'), function (error, lines) {
  if (error) throw error;
  console.log(lines);
});
```

Or even...

```javascript
var dataNoComments = cadence(function (step, name) {
  step.call({}, ['lines'], function () {
    fs.readFile(name, 'utf8', step(step, function (body) {
      return body.split(/\n/).slice(0, -1);
    }));
  }, function () {
    return this.lines.reject(/^\s*#/);
  });
});

dataNoComments(path.join(__dirname + 'data'), function (error, lines) {
  if (error) throw error;
  console.log(lines);
});
```

Here's a way to use the this object so that I can still use objects in the
future. I'm not actually using objects as of yet, so they can still represent
something.

I don't believe assigning this is going to be in the initial release. Passing
`this` consistently will be, but not assigning `this` directly. I'm not sure
that it is all that much of a verbiage savings.

```javascript
DataFile.prototype.load = cadence(function (step, name) {
  step(function () {
    fs.readFile(name, 'utf8', step());
  }, function (lines) {
    this.lines = body.split(/\n/).slice(0, -1);
    return this;
  });
});
```

Rebinding `this` is definitely something that I need to consider, so it comes
after an initial release.

## Step Out of Cadence

Always mentioned when whinging about callbacks is the temple of doom, yet
Cadence has evolved to where it requires you to use step with what was once
called a sub-cadence. It might be nice to reduce the nesting.

```javascript
var cadence = require('cadence'), step = cadence();

var delinate = cadence(step, function (name) {
  fs.readFile(name, 'utf8', step());
}, function (body) {
  return body.split(/\n/).slice(0, -1);
});

delinate(__filename, function (error, lines) {
  if (error) throw error;
  console.log(lines);
});
```

That's all I got, though. Tell `cadence` that you have `step` and it doesn't
need to be passed in. Why not just do ignore it though?

```javascript
var cadence = require('cadence'), step = cadence();

var delinate = cadence(function (step, name) {
  fs.readFile(name, 'utf8', step());
}, function (body) {
  return body.split(/\n/).slice(0, -1);
});

delinate(__filename, function (error, lines) {
  if (error) throw error;
  console.log(lines);
});
```

Bad example because there are only two steps. I'm not sure there are good
examples. I'll have to look in practice, I doubt there are going to be many
opportunities to skip creating a sub-cadence immediately.

## Extraneous Callbacks

Not sure what to do about extraneous callbacks, callbacks that occur after the
step has finished. One would think that the right thing to do would be to throw
an exception, but what if one callback has errored, while others are still
outstanding?

Let's say your reading a file and querying a database, but the network to the
database is down? The database returns with an error, essentially ending the
step, but the file is still pending. The user has established that the next step
needs both the query results and the file contents. They're only getting half
that. The database error ruins the step.

The user might handle the error in the callback given to the whole cadence,
handle it by displaying an error page, but now the file returns and we through a
process terminating exception.

The filp side is that the file might also error. Only the database error is
reported, so the file read fails silently. The administrator reconnects the
network, and now file system problems appear. Why couldn't the administrator
know about all the problems before setting out to fix things? Why must these
reports come in one after another?

I'll assume that if the developer wants step by step error reporting, that they
will perform these actions step by step. The problem is this: there is only a
scalar conduit for errors, where actions that create errors may be occurring in
parallel. I've decided that I don't want to create an error array, since I won't
know when to stop listening for errors, that it will be a first unhandled error
is the return value of the cadence, then cadence will hang around and swallow
your callbacks for you, which is nice enough, isn't it?

## Events or Shift?

There is a strong desire to avoid method chaining. I've thought that I could add
a `shift` method to the function, which would be like a bind method, and not
terribly un-javascript like. It would do one thing only, shift that expected
error off of the function signature. It could be called `shift`, or it could be
called `event`.

Is the signature of the callback a separate part of the declaration? If so, if
we are using this means to shift the error, shouldn't we also use it to define
the arity of the function?

```javascript
cadence(function (step, ee) {
  step(function () {
    ee.on('end', step()(1, 1));
    // or..
    ee.on('end', step()(-1, 1));
  });
});
```

We go back to being sneaky, because we know that the first argument is going to
be an `Error` always, and if anyone is returning a number, then they are silly.

They might be returning a string, though, that isn't quite a number. We can
simply do `typeof error` and it must be `"number"`.

But, then, are we defining arity, or are we shifting, or both? If we are
shifting then we always have to say; `(-1)`. That first option is going to be
ambiguous. When we're not working with Node.js, we're going to call that a lot.

Are we going to be not working with Node.js often? Getting this out into the
world, I'm going to have to see what it is like to write copious even handling
code with Cadence.

My concern is that if someone uses domains, they have to know the difference
between system calls that swallow the error, and other callbacks that do not.

Domains actually make Node.js worse. It is too bad that we couldn't stick with
the one true pattern, the `(error, result)` callback. Not excited about domains,
nor about streams, actually. Oh, no. I'm wrong. It doesn't shift the callback,
it simply catches any exception thrown in the event loop.

What is the state of exception handling in Cadence? Can it catch an exception
thrown too soon?

Getting back to it, I don't believe that `step()(-1)` is going be something that
people will be happy to type, it might be easier to have `step` assign the error
handler, which still makes sense, because I don't need a general purpose shift.

```javascript
cadence(function (step, ee) {
  step(function () {
    step('on', 'end', ee);
    // versus...
    ee.on('end', step()(-1));
    // versus...
    ee.on('end', step().shift());
  });
});
```

Then domains can make the error handling nausea go away.

---

Now that I have a better understanding of Domains, I see that they exist to
handle the problem of uncaught errors, and that most event systems are going to
have some form of default error handler, so why fight it? Why try to duplicate
that behavior for a single case?

The problem that I'm trying to solve is the child process problem; creating a
child process means assigning three error handlers, one for the process itself,
then one each for stdout and stderr. Domains are supposed to make this problem
go away. Domains are the solution provided by Node.js for the problem of a
default error handler in an event system.

My clever incantation, where I assign single error handler to three different
objects, it obscures too much of what is going on, the method is now a string,
the event is also a string, the method name comes before the object, or else the
object comes before all the strings, `'error'` is special, etc..

I'm leaning toward this...

```javascript
cadence(function (step, ee) {
  ee.on('error', step.event([]));
  var d = new Domain;
  d.run(function () {
    step(function () {
      ee.on('data', step.event([]));
      ee.on('end', step.event());
    }, function (data) {
      console.log(data);
      ee.on('other', step.event());
      ee.on('error', step.event([], Error));
    }, function (error) {
      if (error.message != 'never mind') step(error);
    }, function (other) {
      console.log(other);
    });
  });
  d.on('error', step.event([]));
});
```

An event is a special thing, breaking the callback pattern. It should not be
specified using a sigil from the beastiary, but instead should have it's own
name. Implementation uses step, but wrappers the result in some way.

The `error, result` pattern is a pattern, but event indicates that we're leaving
that pattern, performing a different sort of programming.

## Domains

Thus, I'm not going to like Domains, but I need to support them to bring people
to Cadence, which, if it is Domain friendly.

Does Cadence look for a Domain object? That would make it particular to Node.js.

Started using Cadence with Domains. Attached some notes about some issues that
I'll have to document.

## Inbox

 * *Loops*: Loops need decisions.

Notes on returning the step function. Notes on event handlers, if you have any.

Take note that the default arity of scalars should be zero, but it is one for
arrays because why would be gather into an array if there is nothing to gather.

What's the difference between a fix-up cadence and a sub-cadence? Can one
replace the other?

Sub-cadences start immediately, scalars when the function ends, arrayed when
they are called. Fix-up cadences are run after a callback returns. Sub-cadences
could be expressed as fix-up cadences, but that would really be the end of the
magic of Cadence, there's got to be some method to the madness, not just we'll
call the next function for you.

In all these things, there is something you sell the user, something they've
been told is bad, that if you're able to get them to trust you that you've not
abused this bad behavior, if you'll navigate it for them, then you almost always
magically unlock new ways of doing things.

With Cadence, we're looking at a tiny library, fully tested, easy enough for a
person to read themselves. We're asking people to pay for this overhead between
calls, the DSL comes from a magic function, which I learned about by creating
Timezone.

Of course, `null` is ambiguous. Need to add arity to indicate a shift instead of
an early return.

Also, note that there is no way to do fix-up cadences for shifted callbacks,
right? Or if there is, then, well, there isn't, right? But if there was, then
that would be the way to do shifted callbacks. (Fuzzy, tired, but something that
allows you to shift with a lot of verbiage can be reduced for events.)

Finally, it may be the case that shifting doesn't count, you have event
handlers, or else you have callbacks, so whatever you use to indicate an event
indicates shifting.

Oh, cute; I was calling the return value from `step` an "inverse future."

How about using the object as a value cache? Or is cache to clever?

Test that callback argument is actually a function. Or what is correct?

**Update**: Yes. Cadence is just begging for a `while` and `until` where `until`
is evaluated at the end of the cadence. Or! Maybe you put `while` anywhere and
it breaks the cadence?

```javascript
cadence(function (step, items) {
  step(step.while(function () { return  items.length }), function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  })
});
```

Or formatted thus...

```javascript
cadence(function (step, items) {
  step(step.while(function () {
    return  items.length
  }), function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  })
});
```

Or...

```javascript
cadence(function (step, items) {
  step(step.exit(function () {
    return !items.length;
  }), function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  })
});
```

How do you return?

```javascript
cadence(function (step, items) {
  var transformed = [];
  step(step.while(function () {
    if (!items.length) return transformed;
  }), function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  })
});
```

Or at the end...

```javascript
cadence(function (step, items) {
  step(function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  }, step.while(function () {
    if (items.length);
  });
});
```

But, we already have an exit. We use `step`. Maybe we want loop?

```javascript
cadence(function (step, items) {
  var transformed = [];
  step.loop(function () {
    var item = items.shift();
    step(function () {
      // do something.
    });
  }, function () {
    if (items.length) step(null, transformed);
  });
});
```

When why do we need `jump`? To jump up and out. Maybe we use named loops?

```javascript
cadence(function (step, items) {
  var transformed = [];
  step.loop("outer", function () {
    var item = items.shift();
    step(function () {
      // do something.
      step.jump("outer");
    });
  }, function () {
    if (items.length) step(null, transformed);
  });
});
```

Or we can keep our jump anywhere, but have a nicer way of labeling.

```javascript
cadence(function (step, items) {
  var items = step.loop(function () {
    var item = items.shift();
    step(function () {
      // this is like a continue, maybe.
      step.jump(items);
      // or maybe, this is like a continue, maybe...
      step(item)(null, terminated);
      // because now we do have a special function of our own creation and we
      // can mark it as such.
      // But, how do we jump out? Have we been jumping forward?
      // Yeah, but we didn't want to make special return cases.
    });
  }, function () {
    if (items.length) step(null, transformed);
  });
});
```

Or if we want to bash syntax harder, we can make `()` mean loop. It loops and
returns a label. That's the syntax bashing way to go.

```javascript
cadence(function (step, items) {
  var items = step(function () {
    var item = items.shift();
    step(function () {
      // this is like a continue, maybe.
      step.jump(items);
      // or maybe, this is like a continue, maybe...
      step(item, transformed);
      // because now we do have a special function of our own creation and we
      // can mark it as such.
    });
  }, function () {
    if (items.length) step(null, transformed);
  })();
});
```

Oh.. And if you give it a count, it loops count times.

And if you give it a function it loops while (or until);

```javascript
cadence(function (step, items) {
  var items = step(function () {
    var item = items.shift();
    step(function () {
      // this is like a continue, maybe.
      step.jump(items);
      // or maybe, this is like a continue, maybe...
      step(item, transformed);
      // because now we do have a special function of our own creation and we
      // can mark it as such.
    });
  })(items.length);
});
```

```javascript
cadence(function (step, items) {
  var items = step(function () {
    var item = items.shift();
    step(function () {
      // this is like a continue, maybe.
      step.jump(items);
      // or maybe, this is like a continue, maybe...
      step(item, transformed);
      // because now we do have a special function of our own creation and we
      // can mark it as such.
    });
  })(function () { return items.length });
});
```

The difference between while and until can be arguments. Entering there will be
no arguments, but exiting there will be.

```javascript
cadence(function (step, items) {
  var items = step(function () {
    var item = items.shift();
    step(function () {
      // this is like a continue, maybe.
      step.jump(items);
      // or maybe, this is like a continue, maybe...
      step(item, transformed);
      // because now we do have a special function of our own creation and we
      // can mark it as such.
    });
  })(function (items) { return items.length });
});
```

That is the Cadence way. Maybe jump doesn't have to search as hard if jumping is
no about loops. If I can write applications without the jump as goto, then I'll
get rid if it.

TK: Move this up and under looping.

Doing loop labels right now, and I might use those instead of assigning jump
labels. Jump labels are cute, but they are unstructured. With labels, I can get
back to having a single `step` function. `Error` is now freed up for the
creation of error handlers, so we only need to choose a sigil for events. That
could be `step(this)`, which means that the function is not a callback, but er,
I got nothing. We could say `step(Error)` implies that the error slot has been
filled or `step(-1)` implies that the slot has been shifted, so that `step(-1,
Error)` means error handler, or just `step(Error)`.

In any case, label invocation. I'm looking at how I'd like to use it, and I'd
like to be able to do it as one liner at times. I chose to make `step.jump`
separate and apart from return values, but then when I used it, and I needed
curly braces to set the jump and set a return value, I didn't like it. I wanted
to be able to make that one-liner because `continue` is a one liner.

Now that I have labels, I'm looking for a way to express those one liners.

```javascript
step(tryagain)      // change flow, but no callback generation
step(tryagain)()    // create a callback optionally by invoking builder
step(tryagain, 1)   // Specify any one explicit argument, here it's arity
tryagain()          // No! Loose the type difference.
```

Then what about immediate returns? Ah, just return true.

```javascript
if (!anygood) return step(tryagain) && 1
```

More Inbox:

 * Prospect, intent, ordain, decree, destine, enjoin, resolute.

## Returns

If you return an array to indicate that it is the next value, then you can
return a boolean to break from a loop at any point, or a label to indicate that
you want to jump to that label.

## Zero to Many

I creates support for zero-to-many calls of a callback, but implemented it
differently for events than for error callbacks. The zero-to-many calls is
really an event thing, because with standard callbacks you are invoking a
function and you are demanding a return. Making the behavior consistent is
inappropriate.

I'm seeing that generally, I want zero-to-many for events, there is no
reasonable case for looping through an array of items and assigning a callback,
because event emitters are streamy things. They are not going to be pinned to a
particular invocation the way that a callback pins to a particular invocation.

Hah. Coming back to this after having broken Cadence, to see that this logic is
the correct logic, that there is no zero-to-many for callbacks, they are always
callbacks and they should always be called once.

## Initial Invocation

Cadence will provide you with a callback for convenience invocations, however it
won't provide you with one when you pass in parameters.

```javascript
// this works
cadence(function (step) {
  // stuff...
})();

// this doesn't
cadence(function (step, count) {
  // stuff...
})(3);
```

What happens when I use default invocation, forget to provide a callback to a
function that is a member of class? This is a nice addition to Cadence when I
use it to write a one off script, but it doesn't work too well when Cadence is
being used to build libraries.

### Jumping the Parent

This might be done quite easily by putting a marker in the invocation. Can make
the point to people that the functions given to Cadence are to participate in
Cadence, and Cadence will attach some notes to them. Can simply attach indexes
too, instead of exposing the full set of internals.

However, the behavior is going to be suggestive instead of absolute. You're not
going to be able to fork a bunch of different paths?

Remember that the invocation stack is not a call stack. The elements in the
invocation stack may be two completely different cadence functions running in
parallel. You could build a stack if you like.

How about we make `step(next)` not return a callback? It simply changes the
control flow of the current execution. It can look back through a call stack and
change the index, but we'd need to keep a call stack, which wouldn't be all that
expensive. There is no way to do it with annotation, it would have to be search.

Actually, you can put it in a variable. Timeouts would be great, though.

This might make more sense because it sets a property of the current function,
changing the control flow of the current function, which is different, I mean
you could have other callbacks as well, you might be gathering results in an
array, etc. Maybe you do want `step.jump`, to show that it is separate from
creating a callback of some sort. I can try that for a few iterations.

Also, add the ability to return from a jump, which makes it easier to break out
of it with a one liner.

 * **TODO**: Breaking up and out; yes, this needs more thought.

## Was Is

It was supposed to be about control flow, jumping, but it's become to be all
about parallelism.

## Stepping Out

One pattern that I've begun to see is along these lines...

```javascript
cadence(function () {
    step(function () {
        database.byId('person', 10, step())
    }, function (person) {
        if (!person) step(null)
        else return person
    }, function (person) {
        // do complicated stuff with person
    })
})
```

Already, I create a special case where you can pass a boolean to indicate that
you should return if the result is not true, but there is nothing that really
indicates what the return value should be, if it is not supposed to be undefined
or null.

```javascript
cadence(function () {
    step(function () {
        database.byId('person', 10, step(true))
    }, function (person) {
        // do complicated stuff with person
    })
})
```

Also, you kind of hide what is going on. Currently, I control flow a bit with
angle brackets, they indicate flow in other ways, so maybe I could use them to
say, escape if not true.

```javascript
cadence(function () {
    step([true, function () {
        database.byId('person', 10, step())
    }], function (person) {
        // do complicated stuff with person
    })
})
```

Also, it occurs to me that it may be enough that, with an undefined return
value, I can use the previous return value. If I want to return undefined for
real, then I can use `[]`.

```javascript
cadence(function () {
    step(function () {
        database.byId('person', 10, step())
    }, function (person) {
        if (!person) step(null, { id: -1 })
    }, function (person) {
        // do complicated stuff with person
    })
})
```

That is a return value, not a callback value. Declaring a callback means that
you expect a callback return value.

## Breaking Out, Breaking Up

Here are some thoughts on breaking out.

```javascript
cadence(function (step) {
    var count = 0
    var retry = step(function (retry) {
        if (retry) count++
        else step(null, 10)
    }, function () {
        return retry(true)
    })
})
```

We kind of already have up and out, but I'm consider whether this is a better
way to say `continue`. You say break by returning early, and you say where
you're breaking to, ah, yes, you might want to break way out, though. Then,
perhaps you return the label, you invoke the label and return to jump, and you
pass the label to step to create a callback. Why does airity need to be
specified?

I've forgotten about nested parameters. Here is a possible jump up.

```javascript
cadence(function (step) {
    var count = 0
    var retry = step(function (retry) {
        if (retry) count++
        else step(null, 10)
    }, function () {
        var inner = step(function () {
          return [ retry(), true ]
        })
    })
})
```

Here is a possible jump out.

```javascript
cadence(function (step) {
    var count = 0
    var retry = step(function (retry) {
        if (retry) count++
        else step(null, 10)
    }, function () {
        var inner = step(function () {
          return [ retry, true ]
        })
    })
})
```

Now our callbacks accept the label and always assume airty, you do not need to
be explicit.

```javascript
cadence(function (step) {
    var count = 0
    var retry = step(function (retry) {
        if (retry) count++
        else step(null, 10)
    }, function () {
        var inner = step(function () {
          echo(1, step(retry()))
        })
    })
})
```

And out.

```javascript
cadence(function (step) {
    var count = 0
    var retry = step(function (retry) {
        if (retry) count++
        else step(null, 10)
    }, function () {
        var inner = step(function () {
          echo(1, step(retry))
        })
    })
})
```

## Making Loop Parameters Explicit

I'm now ready to go with the double parenthesis, which is not unlike invoking
step then calling callback directly. Why?

 * Because putting stuff in the Cadence is ugly, breaks.
 * Because the super overloaded parens are super overloaded.
 * Let's see, two arguments array and array, or array and number, and we have a
 gathering loop. Array is a for each loop. Number is a counted loop. Then how do
 we pass in parameters? We chose null and an argument. What is wrong with this
 exactly? It seems to work. When will I need to loop over and pass in arguments?

My confidence might have been shaken by the loop breakage. Leave it for a while
now that it works.

*Update*: Yes, loops are getting difficult now that gathered loops work
correctly and I'm starting to use them. Loop parameters at the end of user
parameters means that user parameters are going to shift, because often times
the loop parameters are gathered, well, if they, then they are at the last step,
which means to prime the loop, we need to provide something to offset for the
arity, because on the subsequent go round, the result from the last step will be
prepended to the arguments, the loop item or item and counter are going to be
appended. They need to be prepended so that they are always in the same place.

*Update*: Should there now be some special way of handling catch? No because
you're catching, and that's how it works in the JavaScript language, you need to
throw to propagate.

## More Breaks

Here are some thoughts on some more breaks.

```
var f = cadence(function (step, string) {
    step(function () { // nested
        var block = step(function () {
            switch (value) {
            case 'inner-return':
                return [ step, 'exit current cadence' ]
            case 'function-return-1':
                return [ cadence, 'exit whole function' ]
            case 'function-return-2':
                return [ step(), 'exit whole function' ]
            case 'block-exit':
                return [ block, 'exit labeled block' ]
            }
        }) // <- (1) no longer necessary
    }, function () {
        console.log('next')
    })
})
```

## Declaration

I never, ever use the flow in Cadence that is built into the root, so I can use
that for more configuration. An example would be to explicitly state the arity
of the return value.

But, I believe I already have a way to specify arity to `step`.

```
cadence(0, function (step) {
    someOtherFunctionWithResultsWeDoNotWant(step())
})
```

## Loops Again

Let's say we make gathered arrays go away.

```javacript
var f = cadence(function (step) {
    var loop = step(function (str) {
        if (str.length > 10) return [ loop, str ]
        else return [ str + str ]
    })("x")
})
```
Gathered loops can be specified by passing an array to step. Argument to loops
can, hmm...

Okay, I'm feeling like the leading argument is the counter, and if you don't
want one the leading argument can be null. Following arguments are parameters.

## Outgoing

I'm not using arrays much. I've never used them, actually. They are parallel.
I'm more likely to use a `forEach` to do something in parallel.

## Events Again

This is how I feel.

```javascript
cadence(function (step) {
    step(function () {
        var ee = new events.EventEmitter
        step(ee, 'data', [])
        step(ee, Error)
        step(child.stdout, 'data', [])
        step(child.stdout, 'end')
        step(child.stdout, Error)
    }, function (data) {
        step(step([function () { }]))
        step(step, [function () {
        }])(step)
    })
})
```

## Gathering Again

Gathering a sub-cadence. What I use a lot is actual serial looping. What I use
almost never is the parallel looping that comes from using an arrayed callback.

The problem is that using an array as a signifier makes it into a gathered
callback, one where a new callback is generated for each invocation of the
array. I use this very rarely though, but I do use it to implement gathering of
`'data'` events from event emitters. I also use it to generate an `Error` event
handler for an event emitter. Those uses are pretty much internal, however.

I want to say that a gathered loop is indicated by passing an array to the
`step` that defines the sub-cadence, but I don't know that this is right. As I
write about it, I'd say that it does not belong where it sits in the invocation
of the loop, the loop invocation is getting so complex and difficult to
document. What should I do? Have a go at documentation?

What I find is that I rarely use parallel operations in practice. The
parallelism comes from embedding a module in a server. Each request has a thread
of execution.

Thus, I believe that loops are common, parallel operations are rare. Parallel
operations require gathering, while loops do not always require gathering, so
maybe gathered loops are also rare. I'd say parallel loops are almost never used
by myself.

Yet, I don't like the look of using an array in the cadence to indicate
gathering.

```
// One thing that I'm not using yet is `Array`.
step(function (value) {
    db.fetch({ key: value })
}, function (record) {
    if (record.status == 'frobinated') {
        return [ record ]
    }
    frobinate(record, step())
})(Array, values)

// Starting to double up function calls.
step(function (value) {
    db.fetch({ key: value })
}, function (record) {
    if (record.status == 'frobinated') {
        return [ record ]
    }
    frobinate(record, step())
})(values)([])

// Starting to double up function calls.
step(function (value) {
    db.fetch({ key: value })
}, function (record) {
    if (record.status == 'frobinated') {
        return [ record ]
    }
    frobinate(record, step())
})(other)([])

// Not going to ever see this.
step(function () {
})([])([])

// Would always have values, or be a variable.
step(function () {

})([ 1, 2, 3 ])([])

// Could see this.
step(function () {

})(4)([])

step(function () {

})(4)([])

// Another way would be a significant language change.

var arrayed = step([])()

array.forEach(step([])(function () {
    // Parralel.
}))

// Except you can't tell the difference between this and the above.
step([])(function () {
})(array)

step(function () {
})

// Oops! Already using `()` for continue.
step(function () { })(values)([])

// Here's a new option.
step([])(function () {})(values)

// Which means, uh, but, no ambiguous.
array.forEach(step([])(function () {
}))

// Arrayed, which will be rarely used.
var arrayed = step([])
var individual = arrayed()

// So, we can reuse that, can't we?
```

## Loops: Not Too Shabby

As I go to implement the new looping construct, I start to realize that I like
the old construct just fine.

```javascript
cadence(function (step) {
    // The only reasonable thing left.
    step([])(function () {
        // operations.
    })(array)

    // What we got now.
    step(function () {
        // operations.
    })([], array)

    // Counted arrays.
    step(function () {
        // operations.
    })([], 8)

    // Forever arrays.
    step(function () {
        // operations.
    })([], null)

    // Basically, anything unreachable.
    step(function () {
        // operations.
    })([], -1)

    // Unreachable.
    step(function () {
        // operations.
    })([], Infinity)

    // So that this is shorthand for...
    step(function () {
        // operations.
    })()

    // ...this.
    step(function () {
        // operations.
    })(Infinity)
})
```

And so, we have one ambiguity, if the user would like to loop over an array, but
pass in an array as an extra, first parameter.

There are a two ways to resolve this ambiguity. First, gather the results, but
ignore them, set arity to `0`. Second, the user can pass the array as a
subsequent parameter. If the user is handling a variable and they don't know
what's in it, they can put an ignored value between it and the mystery variable.

Semantically, you're going to see the `[]` in the code, which is the sigil for
gathered operations. When implementing an each loop, it is not going to be
common to see two literals next to each other. The `[]` is terse, which
according to the aesthetics of Cadence is more pleasing.

In fact, if arity is zero, we can skip gathering.


## Continue and Out Callbacks Outgoing

Now I don't like the `step(label)` construct, nor `step(label())` to create a
callback that continues. I've removed `step(null)`, so either I reintroduce it,
which I don't want to do, or I remove the other. Stepping out should be a
`return` because that is what it feels like, an exit. What does it mean if you
have additional callbacks that do not specify a label, or specify a conflicting
label? I suppose you simply say that that is undefined.

Might leave it. Wondering about how to test additional constructs. Say continue
and a cadnece, does that mean we continue with the results?

```javascript
var label = step(function (index, count, letter) {
    if (count < 10) step(label(), function () {
        echo(count + 1, step())
        echo(letter + letter, step())
    })
})(1, count, '_')
```

You need to embrace the ability to say, "is undefined."

## Advanced Loop Control

You could accept a function that does cool things with loops. You can define the
existing operations in terms of the function. The funciton returns an array of
vargs to prepend to the call to the start of the loop, or else it returns null.


## Base Function Tidy

What does a `cadence` that returns nothing return? It will return `step`. Why
would you have a base cadence that returns nothing? If it does return nothing
then it should not do the default and return it's arguments.

Arity for the base function would be nice.

The base function should assert that it gets only one step.

## The `step` Misnomer

There is a decision along the lines of converting Strata to Cadence, it is the
name of the `step` function in Cadence.

In Cadence I call the series of anonymous functions in a cadence, and each
function in the cadence a step. Because I was inspired by the
[step](https://github.com/creationix/step) module by Tim Caswell, I named the
function that is the first argument to a Cadence body `step`. The `step`
function creates callbacks in steps and it also creates cadences. The one thing
that it does not do is create steps, steps are just anonymous functions.

This is miserable to document and to discuss. I can't get past it in the
documentation. I've had to vocalize these distinctions more than once.

People can accept that a library can export a function that is named for the
library and have a concept inside it for which the library is named and that the
function and the concept do not map one to one. `async` and `step` are examples
of that.

But, to have concepts that you're introducing, **cadences** with **steps** and
then name something within the library `step` that doesn't map directly to one
of those concepts, you're going to constantly be explaining this, it is going to
be a stupid legacy caveat that you're introducing before adoption.

Yes, there are charming examples of this everywhere, but I'm sure it is more
commonly associated with software that never had more than one user.

When I last visited this, I considered using `$` for `step`. All sigils all the
time. But that is even harder to document. The `$` function, what do you call
that in English. How do you read that aloud? The dollar function? Then Cadence
goes so squiggly, it appears to be too precious, to clever.

It should be a word. It should be a verb. The only verb that stands out is
`make`.

`build` is way, way too long, and it is hard to type, and it looks horrible to
see over and over again, and it makes me think of building software, which makes
me think of Maven, Ant, Rake, Grunt and all the horrible solutions for that task
that are not make.

`make` also makes me think of building software, but it makes me think happy
thoughts. It is not too long. It is not too short.

What is hard to get rid of is this:

```javascript
var f = cadence(function (step) {})
```

That `cadence(function (step) {` is so adorable. It also makes us think of
marching, instead of singing, where the metaphor makes more sense. Cadence was
inspired by Step and so was the name.

Another word is `mint`, which might do, which would also be `coin`. Which ones
look bests nestled up to parenthesis?

```
step()
make()
coin()
mint()
```

Well, `coin()` doesn't look pleasant. `step()` looks right and wonderful to me.
`make()` and `mint()` both look acceptable, but `make()` is rounder than
`mint()` which is sticky.

A word fitting with the metaphor would be `call`. Unfortunately, that has a
meaning in computer programming that trumps any meaning that could be borrowed
from the metaphor.

`async`. The name of the function is `async()`.

### Assume Serial Error

Instead of assuming parallel errors because Cadence encourages parallelism,
assume serial errors because Cadence discourages parallelism, or rather, I
don't use it much, it is much easier to think in serial.

Couldn't we determine, by the number and nature of callbacks, if we should catch
an error or errors? That would be wicked, but no different from asking the user
to choose. If you call `async` more than once, or you create an arrayed
callback, then you will catch an array of errors.

### Minimal Cadence

I've been using Cadence now for three years. It works well for me. It is an
advantage to use Cadence to simplify the reasoning around asynchronous
programming.

When I first created Strata, I used

Wow! Cannot make the words.

 * Strata had an asynchronous `get` because Streamline.js made that easy. If we
 all used Streamline.js, this would not be a problem, but we don't, and using
 Strata with all that asynchronicity would be hard, but I'd never notice,
 because I'd be using Streamline.js.
 * Streamline.js has outstanding performance.
 * In all this time, I've used and would miss, finalizers and try/catch, that is
 the reasoning I don't want to revisit with every project.
 * Trampolines are also vital, requiring me to otherwise think about the stack.
 * I've never used parallelism. Now that I need parallelism everywhere, I am not
 not turning to the buried and unqueued parallelism of Cadence. It goes.
 * We still have parallel operations, but they are heterogeneous. A catch block
 will take just an error. It will be called for each error, until the catch
 block throws an error, or an error is missed by the regular expression.
 * We remove arity and arrayed callbacks. We remove fixups, which are as easily
 expressed using a sub-cadence.
 * Remove any special form of sub-cadence; fixups, parallels, etc.
 * Finalizers still work correctly as the next step.
 * Create a minimal Cadence that smokes the benchmarks, if at all possible. If
 not, then minimal Cadence doesn't buy us anything, and we move onto something
 else.

### Designing With Cadence

Do not call user callbacks from within a Cadence.

```javascript
var service = require('./service')

function Notifier = function (options) {
    this.onitem = options.onitem
    this.onerror = options.onerror
}

Notifier.prototype.poll = cadence(function (async) {
    var loop = async(function () {
        setTimeout(async(), 1000)
    ], [function () {
        service.poll(async())
    }, function (error) {
        this.onerror(error)
        return [ loop() ]
    }], function (item) {
        this.onitem(item)
    })()
})
```

Above we see a polling loop that catchers errors and calls a user specified
callback. Now below we see that the user wants to panic on error.

```javascript
var notifier = new Notifier({
    onerror: function (error) {
        throw error
    },
    onitem: function (item) {
        console.log(item)
    }
})

function poll () {
    notifier.poll(function (error) {
        if (error) console.log(error.stack)
        setImmediate(poll)
    })
}

poll()
```

In this case, our dear user wants to panic on a notifier error, but if there is
problem with the notifier loop itself, our dear user wants to retry. This is a
convolute example, indicating that the whole contraption is whacky.

Calling the user specified callback is what you need to look out for. A cadence
is supposed to return a result. Cadence will then call an error-first callback
outside of any Cadence error handling so that an error will propagate up and out
and terminate the program. That's how it is supposed to work.

You're not going to encounter this in everyday Cadence programming. I
encountered it developing [Turnstile](https://github.com/bigeasy/turnstile).
This is a queue where you fire and forget, so I wanted to have a place that
would catch all errors, but really what I want to do is pass the error handling
strategy as the last argument because without it there is no context for the
error.

### Documentation

I believe that my exmaples would be better expressed in a giant proof test, so
that I can have namespaces for each test, and so I can copy and paste from it,
so each step in the proof test becomes part of my documentation.

### Design Decsions

 * The `cadence` builder function itself is not optimized. It is not slow. Is is
 quite fast, but it is not itself optimized. I'm going to focus optimization
 energy on it. Cadence functions are generally meant to be build and named, and
 not anonymous.
 * Finalizers once ran at the end of the cadence. This is no more. At times it
 seems like a cool feature to reintroduce.

### The Rules of Cadence

 * The function body is a cadence with a single step.
 * The `async` function is only valid when used within a `step`.

### Cadence Concepts

 * Asynchronous stack.
 * Utilities that call error-first callbacks versus utilities that call a
 callback.
