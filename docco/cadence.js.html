<!DOCTYPE html>

<html>
<head>
  <title>cadence.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>cadence.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> stack = [], push = [].push, JUMP = {}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cadence</span> (<span class="hljs-params">parent, finalizers, self, steps, vargs, callback, outer</span>) </span>{
    <span class="hljs-keyword">this</span>.parent = parent
    <span class="hljs-keyword">this</span>.finalizers = []
    <span class="hljs-keyword">this</span>.self = self
    <span class="hljs-keyword">this</span>.steps = steps
    <span class="hljs-keyword">this</span>.callback = callback
    <span class="hljs-keyword">this</span>.loop = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.cadence = outer || <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">this</span>.outer = outer
    <span class="hljs-keyword">this</span>.cadences = []
    <span class="hljs-keyword">this</span>.results = []
    <span class="hljs-keyword">this</span>.errors = []
    <span class="hljs-keyword">this</span>.called = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>.sync = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">this</span>.waiting = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.vargs = vargs
}

</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>TODO Expand on this. You keep coming back here and saying, oh, no, I need to
give up on a step if there is an error. I’m not returning from this because
there is an error and all the callbacks are not returning. I need to return
immediately if there is an error, and then have a lot more code to deal with
the stragglers that return.</p>
<p>Go back to your code. Try to explain to me why one error first callback
function returning an error is preventing another, completely different
callback function from returning an error. Pretend the are calls to open two
separate files and tell me why the orderly error reporting of the inability
to open one file should prevent the completion of the opening of another.
You’re probably doing something complicated, a callback is deferred, and
neglecting to notify the deferred callback of an error.</p>
<p>In short, this code is fine. If you were not using Cadence either you would
not have noticed the problem, or else you’ve have some sort of straggler
issue causing your code to continue after you’ve responded to an error.</p>
<p>TODO Update. Yes, good point. This is rare in production code, but I do
encounter it a lot in testing where I’m testing race conditions in concurrent
code, the kind of code that Cadence has made it easy for me to write.</p>
<p>Because this is rare in production, it’s not all that difficult to accept
that Cadence should return on the first error, then silently swallow all
subsequent errors. That seems ugly, but not advancing is also ugly, and in
both cases the ugliness is avoided by writing code that runs serially.
(Parallel code using the Node.js event loop is a boondoggle.)</p>
<p>The logic isn’t that much more difficult.</p>
<p>It does present challenges when you consider what it means to run finalizers
early.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
Cadence.prototype.resolveCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, error, vargs</span>) </span>{
    <span class="hljs-keyword">if</span> (error == <span class="hljs-literal">null</span>) {
        result.vargs = vargs
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.errors.push(error)
    }
    <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.called === <span class="hljs-keyword">this</span>.results.length) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.waiting) {
            invoke(<span class="hljs-keyword">this</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.sync = <span class="hljs-literal">true</span>
        }
    }
}

Cadence.prototype.createCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">var</span> result = { <span class="hljs-attr">vargs</span>: [] }

    self.results.push(result)
    self.sync = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">return</span> callback

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span> (<span class="hljs-params">error</span>) </span>{
        <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
        <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; I; i++) {
            vargs[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
        }
        self.resolveCallback(result, error, vargs)

        <span class="hljs-keyword">return</span>

</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>This try/catch will prevent V8 from marking this function of
optimization because it will only ever run once.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* istanbul ignore next */</span>
        <span class="hljs-keyword">try</span> {} <span class="hljs-keyword">catch</span>(e) {}
    }
}

Cadence.prototype.createCadence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
    <span class="hljs-keyword">var</span> callback = <span class="hljs-keyword">this</span>.createCallback()

    <span class="hljs-keyword">var</span> cadence = <span class="hljs-keyword">new</span> Cadence(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.finalizers, <span class="hljs-keyword">this</span>.self, vargs, [], callback, <span class="hljs-keyword">this</span>.outer)

    <span class="hljs-keyword">this</span>.cadences.push(cadence)

    <span class="hljs-keyword">return</span> looper

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">looper</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
        <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
            vargs[i] = <span class="hljs-built_in">arguments</span>[i]
        }
        <span class="hljs-keyword">return</span> cadence.startLoop(vargs)
    }
}

Cadence.prototype.startLoop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
    <span class="hljs-keyword">this</span>.loop = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">this</span>.vargs = vargs
    <span class="hljs-keyword">this</span>.outer = <span class="hljs-keyword">this</span>

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">continue</span>: { <span class="hljs-attr">jump</span>: JUMP, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">break</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">cadence</span>: <span class="hljs-keyword">this</span> },
        <span class="hljs-attr">break</span>: { <span class="hljs-attr">jump</span>: JUMP, <span class="hljs-attr">index</span>: <span class="hljs-literal">Infinity</span>, <span class="hljs-attr">break</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">cadence</span>: <span class="hljs-keyword">this</span> }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> cadence = stack[stack.length - <span class="hljs-number">1</span>]
    <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
    <span class="hljs-keyword">if</span> (I) {
        <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
            vargs[i] = <span class="hljs-built_in">arguments</span>[i]
        }
        <span class="hljs-keyword">return</span> cadence.createCadence(vargs)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> cadence.createCallback()
    }
}

<span class="hljs-keyword">async</span>.continue = { <span class="hljs-attr">jump</span>: JUMP, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">break</span>: <span class="hljs-literal">false</span> }
<span class="hljs-keyword">async</span>.break = { <span class="hljs-attr">jump</span>: JUMP, <span class="hljs-attr">index</span>: <span class="hljs-literal">Infinity</span>, <span class="hljs-attr">break</span>: <span class="hljs-literal">true</span> }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span> (<span class="hljs-params">fn, self, vargs</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> ret = fn.apply(self, vargs)
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> [ ret, e ]
    }
    <span class="hljs-keyword">return</span> [ ret ]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">cadence</span>) </span>{
    <span class="hljs-keyword">var</span> vargs, fn
    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">if</span> (cadence.errors.length) {
</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Break on error cadence is frustrated further by catch blocks that
would restore forward motion. I suppose you’d only short-circuit
cadences subordinate to this cadence.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (cadence.catcher) {
                <span class="hljs-keyword">var</span> catcher = cadence.catcher, errors = cadence.errors
                fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> catcher.call(<span class="hljs-keyword">this</span>, errors[<span class="hljs-number">0</span>], errors)
                }
            } <span class="hljs-keyword">else</span> {
                fn = <span class="hljs-literal">null</span>
                cadence.loop = <span class="hljs-literal">false</span>
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (cadence.results.length == <span class="hljs-number">0</span>) {
</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We had no async callbacks, so use the return value.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                vargs = cadence.vargs
</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Check for a loop controller in the return values.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (vargs[<span class="hljs-number">0</span>] &amp;&amp; vargs[<span class="hljs-number">0</span>].jump === JUMP) {
                    <span class="hljs-keyword">var</span> jump = vargs.shift()
</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Walk up to the jumping cadence setting all the
sub-cadences along the way to their last step. We
continue with the current cadence, not the destination.
We don’t skip finalizers. When we continue, if the
current cadence is not the jumping cadence, we’re going
to run the exit procedures for each sub-cadence.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">var</span> destination = jump.cadence || cadence.cadence
                    <span class="hljs-keyword">var</span> iterator = cadence
                    <span class="hljs-keyword">while</span> (destination !== iterator) {
                        iterator.loop = <span class="hljs-literal">false</span>
                        iterator.index = iterator.steps.length
                        iterator = iterator.parent
                    }
</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Set the index and stop looping if this is a <code>break</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                    iterator.index = <span class="hljs-built_in">Math</span>.min(jump.index, iterator.steps.length)
                    iterator.loop = iterator.loop &amp;&amp; ! jump.break
                }
            } <span class="hljs-keyword">else</span> {
</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Combine the results of all the callbacks into an single array
of arguments that will be used to invoke the next step.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                cadence.vargs = vargs = []
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = cadence.results.length; i &lt; I; i++) {
                    <span class="hljs-keyword">var</span> vargs_ = cadence.results[i].vargs
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, J = vargs_.length; j &lt; J; j++) {
                        vargs.push(vargs_[j])
                    }
                }
            }
</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>On to the next step.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            fn = cadence.steps[cadence.index++]
        }

        <span class="hljs-keyword">if</span> (fn == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (cadence.finalizers.length) {
</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>We’re going to continue to loop until all the finalizers have
executed. The step index is going to go beyond length of the
step array, but that’s okay.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> finalizer = cadence.finalizers.pop(), errors = cadence.errors
                fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">return</span> finalizer.vargs
                    }, [finalizer.steps[<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
                        <span class="hljs-keyword">if</span> (errors.length) <span class="hljs-keyword">throw</span> errors[<span class="hljs-number">0</span>]
                        <span class="hljs-keyword">throw</span> error
                    }], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (errors.length) <span class="hljs-keyword">throw</span> errors[<span class="hljs-number">0</span>]
                        <span class="hljs-keyword">return</span> vargs
                    })
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cadence.loop) {
</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Go back to the first step.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                fn = cadence.steps[<span class="hljs-number">0</span>]
                cadence.index = <span class="hljs-number">1</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cadence.errors.length) {
</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Return the first error we received.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                (cadence.callback).apply(<span class="hljs-literal">null</span>, [ cadence.errors[<span class="hljs-number">0</span>] ])
                <span class="hljs-keyword">break</span>
            } <span class="hljs-keyword">else</span> {
</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>TODO No longer feel compelled keep this shim for some stupid
library that was using <code>arguments.length</code> to determine if it
has been called back as an error first callback or an event
emitter.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (vargs.length !== <span class="hljs-number">0</span>) {
                    vargs.unshift(<span class="hljs-literal">null</span>)
                }
                (cadence.callback).apply(<span class="hljs-literal">null</span>, vargs)
                <span class="hljs-keyword">break</span>
            }
        }

        cadence.called = <span class="hljs-number">0</span>
        cadence.cadences = []
        cadence.results = []
        cadence.errors = []
        cadence.sync = <span class="hljs-literal">true</span>
        cadence.waiting = <span class="hljs-literal">false</span>
        cadence.catcher = <span class="hljs-literal">null</span>

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(fn)) {
            <span class="hljs-keyword">if</span> (fn.length === <span class="hljs-number">1</span>) {
                cadence.finalizers.push({ <span class="hljs-attr">steps</span>: fn, <span class="hljs-attr">vargs</span>: vargs })
                <span class="hljs-keyword">continue</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fn.length === <span class="hljs-number">2</span>) {
                cadence.catcher = fn[<span class="hljs-number">1</span>]
                fn = fn[<span class="hljs-number">0</span>]
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fn.length === <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">var</span> filter = fn
                cadence.catcher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
                    <span class="hljs-keyword">if</span> (filter[<span class="hljs-number">1</span>].test(error.code || error.message)) {
                        <span class="hljs-keyword">return</span> filter[<span class="hljs-number">2</span>].call(<span class="hljs-keyword">this</span>, error)
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">throw</span> error
                    }
                }
                fn = fn[<span class="hljs-number">0</span>]
            } <span class="hljs-keyword">else</span> {
                cadence.vargs = [ vargs ]
                <span class="hljs-keyword">continue</span>
            }
        }

        stack.push(cadence)

        <span class="hljs-keyword">var</span> ret = call(fn, cadence.self, vargs)
</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>^^^^</p>

            </div>

            <div class="content"><div class='highlight'><pre>
        stack.pop()

        <span class="hljs-keyword">if</span> (ret.length === <span class="hljs-number">2</span>) {
            cadence.errors.push(ret[<span class="hljs-number">1</span>])
            cadence.vargs = vargs
            cadence.sync = <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = cadence.cadences.length; i &lt; I; i++) {
                invoke(cadence.cadences[i])
            }
            <span class="hljs-keyword">if</span> (ret[<span class="hljs-number">0</span>] !== <span class="hljs-keyword">void</span>(<span class="hljs-number">0</span>)) {
                cadence.vargs = <span class="hljs-built_in">Array</span>.isArray(ret[<span class="hljs-number">0</span>]) ? ret[<span class="hljs-number">0</span>] : [ ret[<span class="hljs-number">0</span>] ]
            }
        }

        <span class="hljs-keyword">if</span> (!cadence.sync) {
            cadence.waiting = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span>
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span> (<span class="hljs-params">self, steps, vargs</span>) </span>{
    <span class="hljs-keyword">var</span> callback = vargs.pop()
    <span class="hljs-keyword">var</span> cadence = <span class="hljs-keyword">new</span> Cadence(<span class="hljs-literal">null</span>, [], self, steps, vargs, callback)
    invoke(cadence)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cadence</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
    <span class="hljs-keyword">var</span> steps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
        steps.push(<span class="hljs-built_in">arguments</span>[i])
    }
    <span class="hljs-keyword">var</span> f
</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Preserving arity costs next to nothing; the call to <code>execute</code> in
these functions will be inlined. The airty function itself will never
be inlined because it is in a different context than that of our
dear user, but it will be compiled.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">switch</span> (steps[<span class="hljs-number">0</span>].length) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I + <span class="hljs-number">1</span>)
            vargs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">async</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
                vargs[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
            }
            execute(<span class="hljs-keyword">this</span>, steps, vargs)
        }
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one</span>) </span>{
            <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I + <span class="hljs-number">1</span>)
            vargs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">async</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
                vargs[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
            }
            execute(<span class="hljs-keyword">this</span>, steps, vargs)
        }
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one, two</span>) </span>{
            <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I + <span class="hljs-number">1</span>)
            vargs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">async</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
                vargs[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
            }
            execute(<span class="hljs-keyword">this</span>, steps, vargs)
        }
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
        f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one, two, three</span>) </span>{
            <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I + <span class="hljs-number">1</span>)
            vargs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">async</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
                vargs[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
            }
            execute(<span class="hljs-keyword">this</span>, steps, vargs)
        }
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
        f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one, two, three, four</span>) </span>{
            <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(I + <span class="hljs-number">1</span>)
            vargs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">async</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
                vargs[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
            }
            execute(<span class="hljs-keyword">this</span>, steps, vargs)
        }
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">default</span>:
</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Avert your eyes if you’re squeamish.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> args = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = steps[<span class="hljs-number">0</span>].length; i &lt; I; i++) {
            args[i] = <span class="hljs-string">'_'</span> + i
        }
        f = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'execute'</span>, <span class="hljs-string">'steps'</span>, <span class="hljs-string">'async'</span>, <span class="hljs-string">'                    \n\
            return function ('</span> + args.join(<span class="hljs-string">','</span>) + <span class="hljs-string">') {                      \n\
                var I = arguments.length                                    \n\
                var vargs = new Array(I + 1)                                \n\
                vargs[0] = async                                            \n\
                for (var i = 0; i &lt; I; i++) {                               \n\
                    vargs[i + 1] = arguments[i]                             \n\
                }                                                           \n\
                execute(this, steps, vargs)                                 \n\
            }                                                               \n\
       '</span>))(execute, steps, <span class="hljs-keyword">async</span>)
    }

    f.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> steps[<span class="hljs-number">0</span>].toString() }

    <span class="hljs-keyword">return</span> f
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variadic</span> (<span class="hljs-params">f, self</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> I = <span class="hljs-built_in">arguments</span>.length
        <span class="hljs-keyword">var</span> vargs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; I; i++) {
            vargs.push(<span class="hljs-built_in">arguments</span>[i])
        }
        <span class="hljs-keyword">return</span> f.call(self, vargs)
    }
}

<span class="hljs-keyword">async</span>.forEach = variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">steps</span>) </span>{
    <span class="hljs-keyword">return</span> variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
        <span class="hljs-keyword">var</span> loop, array = vargs.shift(), index = <span class="hljs-number">-1</span>
        steps.unshift(variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
            index++
            <span class="hljs-keyword">if</span> (index === array.length) <span class="hljs-keyword">return</span> [ loop.break ].concat(vargs)
            <span class="hljs-keyword">return</span> [ array[index], index ].concat(vargs)
        }))
        <span class="hljs-keyword">return</span> loop = <span class="hljs-keyword">this</span>.apply(<span class="hljs-literal">null</span>, steps).apply(<span class="hljs-literal">null</span>, vargs)
    }, <span class="hljs-keyword">this</span>)
}, <span class="hljs-keyword">async</span>)

<span class="hljs-keyword">async</span>.map = variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">steps</span>) </span>{
    <span class="hljs-keyword">return</span> variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
        <span class="hljs-keyword">var</span> loop, array = vargs.shift(), index = <span class="hljs-number">-1</span>, gather = []
        steps.unshift(variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
            index++
            <span class="hljs-keyword">if</span> (index === array.length) <span class="hljs-keyword">return</span> [ loop.break, gather ]
            <span class="hljs-keyword">return</span> [ array[index], index ].concat(vargs)
        }))
        steps.push(variadic(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vargs</span>) </span>{
            gather.push.apply(gather, vargs)
        }))
        <span class="hljs-keyword">return</span> loop = <span class="hljs-keyword">this</span>.apply(<span class="hljs-literal">null</span>, steps).apply(<span class="hljs-literal">null</span>, vargs)
    }, <span class="hljs-keyword">this</span>)
}, <span class="hljs-keyword">async</span>)

<span class="hljs-built_in">module</span>.exports = cadence

</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
